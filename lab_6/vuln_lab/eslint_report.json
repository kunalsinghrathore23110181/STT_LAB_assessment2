[{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/scripts/build.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":12,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":12,"endColumn":20},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":38,"column":27,"nodeType":"CallExpression","endLine":38,"endColumn":67},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":42,"column":31,"nodeType":"CallExpression","endLine":42,"endColumn":70},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":43,"column":32,"nodeType":"CallExpression","endLine":43,"endColumn":71},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":58,"column":9,"nodeType":"MemberExpression","endLine":58,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":61,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":110,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":124,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":149,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":166,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":170,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'process' is not defined.","line":171,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":171,"endColumn":12},{"ruleId":"no-undef","severity":2,"message":"'TextEncoder' is not defined.","line":175,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":175,"endColumn":36}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { readFileSync, writeFileSync, mkdirSync } from 'fs';\nimport { join, dirname as pathDirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport { build } from 'esbuild';\nimport { globSync } from 'glob';\nimport { minify as jsMinify } from 'terser';\nimport { minify as htmlMinify } from 'html-minifier';\nimport JSZip from \"jszip\";\nimport obfs from 'javascript-obfuscator';\nimport pkg from '../package.json' with { type: 'json' };\n\nconst env = process.env.NODE_ENV || 'mangle';\nconst mangleMode = env === 'mangle';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = pathDirname(__filename);\n\nconst ASSET_PATH = join(__dirname, '../src/assets');\nconst DIST_PATH = join(__dirname, '../dist/');\n\nconst green = '\\x1b[32m';\nconst red = '\\x1b[31m';\nconst reset = '\\x1b[0m';\n\nconst success = `${green}✔${reset}`;\nconst failure = `${red}✔${reset}`;\n\nconst version = pkg.version;\n\nasync function processHtmlPages() {\n    const indexFiles = globSync('**/index.html', { cwd: ASSET_PATH });\n    const result = {};\n\n    for (const relativeIndexPath of indexFiles) {\n        const dir = pathDirname(relativeIndexPath);\n        const base = (file) => join(ASSET_PATH, dir, file);\n\n        const indexHtml = readFileSync(base('index.html'), 'utf8');\n        let finalHtml = indexHtml.replaceAll('__VERSION__', version);\n\n        if (dir !== 'error') {\n            const styleCode = readFileSync(base('style.css'), 'utf8');\n            const scriptCode = readFileSync(base('script.js'), 'utf8');\n            const finalScriptCode = await jsMinify(scriptCode);\n            finalHtml = finalHtml\n                .replaceAll('__STYLE__', `<style>${styleCode}</style>`)\n                .replaceAll('__SCRIPT__', finalScriptCode.code);\n        }\n\n        const minifiedHtml = htmlMinify(finalHtml, {\n            collapseWhitespace: true,\n            removeAttributeQuotes: true,\n            minifyCSS: true\n        });\n\n        // const encodedHtml = Buffer.from(minifiedHtml, 'utf8').toString('base64');\n        const encodedHtml = stringToHex(minifiedHtml);\n        result[dir] = JSON.stringify(encodedHtml);\n    }\n\n    console.log(`${success} Assets bundled successfuly!`);\n    return result;\n}\n\nfunction generateJunkCode() {\n    const minVars = 50, maxVars = 500;\n    const minFuncs = 50, maxFuncs = 500;\n\n    const varCount = Math.floor(Math.random() * (maxVars - minVars + 1)) + minVars;\n    const funcCount = Math.floor(Math.random() * (maxFuncs - minFuncs + 1)) + minFuncs;\n\n    const junkVars = Array.from({ length: varCount }, (_, i) => {\n        const varName = `__junk_${Math.random().toString(36).substring(2, 10)}_${i}`;\n        const value = Math.floor(Math.random() * 100000);\n        return `let ${varName} = ${value};`;\n    }).join('\\n');\n\n    const junkFuncs = Array.from({ length: funcCount }, (_, i) => {\n        const funcName = `__junkFunc_${Math.random().toString(36).substring(2, 10)}_${i}`;\n        return `function ${funcName}() { return ${Math.floor(Math.random() * 1000)}; }`;\n    }).join('\\n');\n\n    return `${junkVars}\\n${junkFuncs}\\n`;\n}\n\nasync function buildWorker() {\n\n    const htmls = await processHtmlPages();\n    const faviconBuffer = readFileSync('./src/assets/favicon.ico');\n    const faviconBase64 = faviconBuffer.toString('base64');\n\n    const code = await build({\n        entryPoints: [join(__dirname, '../src/worker.js')],\n        bundle: true,\n        format: 'esm',\n        write: false,\n        external: ['cloudflare:sockets'],\n        platform: 'browser',\n        target: 'es2020',\n        define: {\n            __PANEL_HTML_CONTENT__: htmls['panel'] ?? '\"\"',\n            __LOGIN_HTML_CONTENT__: htmls['login'] ?? '\"\"',\n            __ERROR_HTML_CONTENT__: htmls['error'] ?? '\"\"',\n            __SECRETS_HTML_CONTENT__: htmls['secrets'] ?? '\"\"',\n            __ICON__: JSON.stringify(faviconBase64),\n            __VERSION__: JSON.stringify(version)\n        }\n    });\n\n    console.log(`${success} Worker built successfuly!`);\n\n    const minifyCode = async (code) => {\n        const minified = await jsMinify(code, {\n            module: true,\n            output: {\n                comments: false\n            },\n            compress: {\n                dead_code: false,\n                unused: false\n            }\n        });\n\n        console.log(`${success} Worker minified successfuly!`);\n        return minified;\n    }\n\n    let finalCode;\n\n    if (mangleMode) {\n        const junkCode = generateJunkCode();\n        const minifiedCode = await minifyCode(junkCode + code.outputFiles[0].text);\n        finalCode = minifiedCode.code;\n    } else {\n        const minifiedCode = await minifyCode(code.outputFiles[0].text);\n        const obfuscationResult = obfs.obfuscate(minifiedCode.code, {\n            stringArrayThreshold: 1,\n            stringArrayEncoding: [\n                \"rc4\"\n            ],\n            numbersToExpressions: true,\n            transformObjectKeys: true,\n            renameGlobals: true,\n            deadCodeInjection: true,\n            deadCodeInjectionThreshold: 0.2,\n            target: \"browser\"\n        });\n\n        console.log(`${success} Worker obfuscated successfuly!`);\n        finalCode = obfuscationResult.getObfuscatedCode();\n    }\n\n    const buildTimestamp = new Date().toISOString();\n    const buildInfo = `// Build: ${buildTimestamp}\\n`;\n    const worker = `${buildInfo}// @ts-nocheck\\n${finalCode}`;\n    mkdirSync(DIST_PATH, { recursive: true });\n    writeFileSync('./dist/worker.js', worker, 'utf8');\n\n    const zip = new JSZip();\n    zip.file('_worker.js', worker);\n    zip.generateAsync({\n        type: 'nodebuffer',\n        compression: 'DEFLATE'\n    }).then(nodebuffer => writeFileSync('./dist/worker.zip', nodebuffer));\n\n    console.log(`${success} Done!`);\n}\n\nbuildWorker().catch(err => {\n    console.error(`${failure} Build failed:`, err);\n    process.exit(1);\n});\n\nfunction stringToHex(str) {\n    const encoder = new TextEncoder();\n    const bytes = encoder.encode(str);\n    return Array.from(bytes, b => b.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/assets/login/script.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":1,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":1,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":2,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":2,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":4,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":4,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":7,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":17,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":17,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":22,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":24,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":28,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":29,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":29,"endColumn":35}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"localStorage.getItem('darkMode') === 'enabled' && document.body.classList.add('dark-mode');\ndocument.getElementById('loginForm').addEventListener('submit', async (event) => {\n    event.preventDefault();\n    const password = document.getElementById('password').value;\n\n    try {\n        const response = await fetch('/login/authenticate', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'text/plain'\n            },\n            body: password\n        });\n\n        const { success, status, message } = await response.json();\n        if (!success) {\n            const passwordError = document.getElementById(\"passwordError\");\n            passwordError.textContent = '⚠️ Wrong Password!';\n            throw new Error(`Login failed with status ${status}: ${message}`);\n        }\n\n        window.location.href = '/panel';\n    } catch (error) {\n        console.error('Login error:', error.message || error);\n    }\n});\n\ndocument.getElementById(\"togglePassword\").addEventListener(\"click\", function () {\n    const passwordInput = document.getElementById(\"password\");\n    const isPassword = passwordInput.type === \"password\";\n    passwordInput.type = isPassword ? \"text\" : \"password\";\n    this.textContent = isPassword ? \"visibility_off\" : \"visibility\";\n});","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/assets/panel/script.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":1,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":1,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":3,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":3,"endColumn":22},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":20,"column":21,"nodeType":"Literal","endLine":20,"endColumn":108},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":21,"column":19,"nodeType":"Literal","endLine":21,"endColumn":94},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":22,"column":19,"nodeType":"Literal","endLine":22,"endColumn":427},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":24,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":6},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":30,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":30,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":43,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":43,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":45,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":46,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":47,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":83,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":33},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":84,"column":23,"nodeType":"MemberExpression","endLine":84,"endColumn":41},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":85,"column":27,"nodeType":"MemberExpression","endLine":85,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":93,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":93,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'FormData' is not defined.","line":94,"column":38,"nodeType":"Identifier","messageId":"undef","endLine":94,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":99,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":99,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":113,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'FormData' is not defined.","line":114,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":123,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":130,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":130,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":132,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'closeResetPass' is defined but never used.","line":135,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":135,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"closeResetPass"},"fix":{"range":[4875,5056],"text":""},"desc":"Remove unused variable 'closeResetPass'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":136,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":138,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":138,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'closeQR' is defined but never used.","line":141,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":141,"endColumn":17,"suggestions":[{"messageId":"removeVar","data":{"varName":"closeQR"},"fix":{"range":[5058,5292],"text":""},"desc":"Remove unused variable 'closeQR'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":142,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":142,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":143,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":143,"endColumn":37},{"ruleId":"no-unused-vars","severity":2,"message":"'darkModeToggle' is defined but never used.","line":148,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":148,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"darkModeToggle"},"fix":{"range":[5294,5466],"text":""},"desc":"Remove unused variable 'darkModeToggle'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":149,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":150,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":155,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":155,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":165,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":165,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":170,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":174,"column":48,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":56},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":182,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":182,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":193,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":197,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":197,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":209,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":209,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'downloadWarpConfigs' is defined but never used.","line":213,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":213,"endColumn":29,"suggestions":[{"messageId":"removeVar","data":{"varName":"downloadWarpConfigs"},"fix":{"range":[7927,8085],"text":""},"desc":"Remove unused variable 'downloadWarpConfigs'."}]},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":215,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":219,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":219,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":224,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":224,"endColumn":30},{"ruleId":"no-unused-vars","severity":2,"message":"'subURL' is defined but never used.","line":232,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":232,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"subURL"},"fix":{"range":[8472,8607],"text":""},"desc":"Remove unused variable 'subURL'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'dlURL' is defined but never used.","line":237,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":237,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"dlURL"},"fix":{"range":[8609,9049],"text":""},"desc":"Remove unused variable 'dlURL'."}]},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":241,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":241,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":250,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":250,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":255,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":255,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":256,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":256,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":257,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":257,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":259,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":259,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":261,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":261,"endColumn":13},{"ruleId":"no-unused-vars","severity":2,"message":"'exportSettings' is defined but never used.","line":264,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":264,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"exportSettings"},"fix":{"range":[9364,9577],"text":""},"desc":"Remove unused variable 'exportSettings'."}]},{"ruleId":"no-undef","severity":2,"message":"'btoa' is not defined.","line":267,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":267,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":268,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":268,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'importSettings' is defined but never used.","line":271,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":271,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"importSettings"},"fix":{"range":[9579,9705],"text":""},"desc":"Remove unused variable 'importSettings'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":272,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":272,"endColumn":27},{"ruleId":"no-unused-vars","severity":2,"message":"'uploadSettings' is defined but never used.","line":277,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":277,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"uploadSettings"},"fix":{"range":[9707,10103],"text":""},"desc":"Remove unused variable 'uploadSettings'."}]},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":283,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":283,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":288,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":288,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'openQR' is defined but never used.","line":292,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":292,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"openQR"},"fix":{"range":[10105,10929],"text":""},"desc":"Remove unused variable 'openQR'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":293,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":293,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":294,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":294,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":296,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":296,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":299,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":299,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":317,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":317,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":318,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":318,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":319,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":319,"endColumn":32},{"ruleId":"no-unused-vars","severity":2,"message":"'updateWarpConfigs' is defined but never used.","line":322,"column":16,"nodeType":"Identifier","messageId":"unusedVar","endLine":322,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"updateWarpConfigs"},"fix":{"range":[11137,12018],"text":""},"desc":"Remove unused variable 'updateWarpConfigs'."}]},{"ruleId":"no-undef","severity":2,"message":"'confirm' is not defined.","line":323,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":323,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":325,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":325,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":326,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":326,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":330,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":330,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":332,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":332,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":336,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":336,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":340,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":340,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":342,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":342,"endColumn":16},{"ruleId":"no-unused-vars","severity":2,"message":"'handleProtocolChange' is defined but never used.","line":346,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":346,"endColumn":30,"suggestions":[{"messageId":"removeVar","data":{"varName":"handleProtocolChange"},"fix":{"range":[12020,12451],"text":""},"desc":"Remove unused variable 'handleProtocolChange'."}]},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":357,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":357,"endColumn":14},{"ruleId":"no-unused-vars","severity":2,"message":"'handlePortChange' is defined but never used.","line":363,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":363,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"handlePortChange"},"fix":{"range":[12453,13022],"text":""},"desc":"Remove unused variable 'handlePortChange'."}]},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":376,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":376,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":383,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":383,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":396,"column":34,"nodeType":"MemberExpression","endLine":396,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":400,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":400,"endColumn":29},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":401,"column":21,"nodeType":"MemberExpression","endLine":401,"endColumn":49},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":401,"column":21,"nodeType":"MemberExpression","endLine":401,"endColumn":42},{"ruleId":"no-unused-vars","severity":2,"message":"'resetSettings' is defined but never used.","line":408,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":408,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"resetSettings"},"fix":{"range":[13812,14898],"text":""},"desc":"Remove unused variable 'resetSettings'."}]},{"ruleId":"no-undef","severity":2,"message":"'confirm' is not defined.","line":409,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":409,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":412,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":412,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":415,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":415,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":417,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":417,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":425,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":425,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":433,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":433,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":435,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":435,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":439,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":439,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'FormData' is not defined.","line":440,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":440,"endColumn":34},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":477,"column":21,"nodeType":"MemberExpression","endLine":477,"endColumn":35},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":478,"column":23,"nodeType":"MemberExpression","endLine":478,"endColumn":39},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":478,"column":43,"nodeType":"MemberExpression","endLine":478,"endColumn":59},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":479,"column":20,"nodeType":"MemberExpression","endLine":479,"endColumn":33},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":517,"column":23,"nodeType":"MemberExpression","endLine":517,"endColumn":32},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":518,"column":9,"nodeType":"MemberExpression","endLine":518,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":532,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":532,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":533,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":533,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":537,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":537,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":547,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":547,"endColumn":22},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":548,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":548,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":556,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":556,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":558,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":558,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":560,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":560,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":570,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":570,"endColumn":22},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":571,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":571,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":572,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":572,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":597,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":597,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":602,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":602,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":614,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":614,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":623,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":623,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":635,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":635,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":643,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":643,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":649,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":649,"endColumn":20},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":653,"column":19,"nodeType":"Literal","endLine":653,"endColumn":63},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":675,"column":27,"nodeType":"Literal","endLine":675,"endColumn":136},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":676,"column":27,"nodeType":"Literal","endLine":676,"endColumn":476},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":685,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":685,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":702,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":702,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":714,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":714,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":726,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":726,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":738,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":738,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":768,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":768,"endColumn":14},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":781,"column":25,"nodeType":"Literal","endLine":781,"endColumn":83},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":787,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":787,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":797,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":797,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":811,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":811,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":823,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":823,"endColumn":14},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":832,"column":25,"nodeType":"Literal","endLine":832,"endColumn":91},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":836,"column":20,"nodeType":"MemberExpression","endLine":836,"endColumn":36},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":836,"column":47,"nodeType":"MemberExpression","endLine":836,"endColumn":63},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":837,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":837,"endColumn":18},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":844,"column":39,"nodeType":"MemberExpression","endLine":844,"endColumn":53},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":845,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":845,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":852,"column":40,"nodeType":"MemberExpression","endLine":852,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":853,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":853,"endColumn":26},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":857,"column":36,"nodeType":"MemberExpression","endLine":857,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":860,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":860,"endColumn":26},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":867,"column":23,"nodeType":"Literal","endLine":867,"endColumn":63},{"ruleId":"security/detect-object-injection","severity":1,"message":"Function Call Object Injection Sink","line":867,"column":69,"nodeType":"MemberExpression","endLine":867,"endColumn":83},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":868,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":868,"endColumn":26},{"ruleId":"no-unused-vars","severity":2,"message":"'logout' is defined but never used.","line":880,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":880,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"logout"},"fix":{"range":[28930,29391],"text":""},"desc":"Remove unused variable 'logout'."}]},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":882,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":882,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":889,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":889,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":891,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":891,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":894,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":894,"endColumn":9},{"ruleId":"no-unused-vars","severity":2,"message":"'resetPassword' is defined but never used.","line":903,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":903,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"resetPassword"},"fix":{"range":[29756,31527],"text":""},"desc":"Remove unused variable 'resetPassword'."}]},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":905,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":905,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":906,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":906,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":907,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":907,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":908,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":908,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":926,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":926,"endColumn":10},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":941,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":941,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":942,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":942,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":945,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":945,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":948,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":948,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":955,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":955,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":979,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":979,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":982,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":982,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":983,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":983,"endColumn":17},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":996,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":996,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":1046,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":1046,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":1054,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":1054,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'btoa' is not defined.","line":1055,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":1055,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":1062,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":1062,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":1072,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":1072,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":1098,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":1098,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'confirm' is not defined.","line":1102,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":1102,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":1110,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":1110,"endColumn":13}],"suppressedMessages":[],"errorCount":151,"fatalErrorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":0,"source":"localStorage.getItem('darkMode') === 'enabled' && document.body.classList.add('dark-mode');\n\nconst form = document.getElementById(\"configForm\");\nconst [\n    selectElements,\n    numInputElements,\n    inputElements,\n    textareaElements,\n    checkboxElements\n] = [\n    'select',\n    'input[type=number]',\n    'input:not([type=file])',\n    'textarea',\n    'input[type=checkbox]'\n].map(query => form.querySelectorAll(query));\n\nconst defaultHttpsPorts = [443, 8443, 2053, 2083, 2087, 2096];\nconst defaultHttpPorts = [80, 8080, 8880, 2052, 2082, 2086, 2095];\nconst domainRegex = /^(?=.{1,253}$)(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)\\.)+[a-zA-Z]{2,63}$/;\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst ipv6Regex = /^\\[(?:(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,7}:|(?:[a-fA-F0-9]{1,4}:){1,6}:[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,5}(?::[a-fA-F0-9]{1,4}){1,2}|(?:[a-fA-F0-9]{1,4}:){1,4}(?::[a-fA-F0-9]{1,4}){1,3}|(?:[a-fA-F0-9]{1,4}:){1,3}(?::[a-fA-F0-9]{1,4}){1,4}|(?:[a-fA-F0-9]{1,4}:){1,2}(?::[a-fA-F0-9]{1,4}){1,5}|[a-fA-F0-9]{1,4}:(?::[a-fA-F0-9]{1,4}){1,6}|:(?::[a-fA-F0-9]{1,4}){1,7})\\]$/;\n\nfetch('/panel/settings')\n    .then(async response => response.json())\n    .then(data => {\n        const { success, status, message, body } = data;\n\n        if (status === 401 && !body.isPassSet) {\n            const closeBtn = document.querySelector(\".close\");\n            openResetPass();\n            closeBtn.style.display = 'none';\n        }\n\n        if (!success) {\n            throw new Error(`status ${status} - ${message}`);\n        }\n\n        const { subPath, proxySettings } = body;\n        globalThis.subPath = encodeURIComponent(subPath);\n        initiatePanel(proxySettings);\n    })\n    .catch(error => console.error(\"Data query error:\", error.message || error))\n    .finally(() => {\n        window.onclick = (event) => {\n            const qrModal = document.getElementById('qrModal');\n            const qrcodeContainer = document.getElementById('qrcode-container');\n\n            if (event.target == qrModal) {\n                qrModal.style.display = \"none\";\n                qrcodeContainer.lastElementChild.remove();\n            }\n        }\n    });\n\nfunction initiatePanel(proxySettings) {\n    const {\n        VLConfigs,\n        TRConfigs,\n        ports,\n        xrayUdpNoises\n    } = proxySettings;\n\n    Object.assign(globalThis, {\n        activeProtocols: VLConfigs + TRConfigs,\n        activeTlsPorts: ports.filter(port => defaultHttpsPorts.includes(port)),\n        xrayNoiseCount: xrayUdpNoises.length,\n    });\n\n    populatePanel(proxySettings);\n    renderPortsBlock(ports.map(Number));\n    renderUdpNoiseBlock(xrayUdpNoises);\n    initiateForm();\n    fetchIPInfo();\n}\n\nfunction populatePanel(proxySettings) {\n    selectElements.forEach(elm => elm.value = proxySettings[elm.id]);\n    checkboxElements.forEach(elm => elm.checked = proxySettings[elm.id]);\n    inputElements.forEach(elm => elm.value = proxySettings[elm.id]);\n    textareaElements.forEach(elm => {\n        const key = elm.id;\n        const element = document.getElementById(key);\n        const value = proxySettings[key]?.join('\\r\\n');\n        const rowsCount = proxySettings[key].length;\n        element.style.height = 'auto';\n        if (rowsCount) element.rows = rowsCount;\n        element.value = value;\n    });\n}\n\nfunction initiateForm() {\n    const configForm = document.getElementById('configForm');\n    globalThis.initialFormData = new FormData(configForm);\n    enableApplyButton();\n\n    configForm.addEventListener('input', enableApplyButton);\n    configForm.addEventListener('change', enableApplyButton);\n    const textareas = document.querySelectorAll(\"textarea\");\n\n    textareas.forEach(textarea => {\n        textarea.addEventListener('input', function () {\n            this.style.height = 'auto';\n            this.style.height = `${this.scrollHeight}px`;\n        });\n    });\n\n    handleFragmentMode();\n}\n\nfunction hasFormDataChanged() {\n    const formDataToObject = (formData) => Object.fromEntries(formData.entries());\n    const configForm = document.getElementById('configForm');\n    const currentFormData = new FormData(configForm);\n\n    const initialFormDataObj = formDataToObject(globalThis.initialFormData);\n    const currentFormDataObj = formDataToObject(currentFormData);\n\n    return JSON.stringify(initialFormDataObj) !== JSON.stringify(currentFormDataObj);\n}\n\nfunction enableApplyButton() {\n    const applyButton = document.getElementById('applyButton');\n    const isChanged = hasFormDataChanged();\n    applyButton.disabled = !isChanged;\n    applyButton.classList.toggle('disabled', !isChanged);\n}\n\nfunction openResetPass() {\n    const resetPassModal = document.getElementById('resetPassModal');\n    resetPassModal.style.display = \"block\";\n    document.body.style.overflow = \"hidden\";\n}\n\nfunction closeResetPass() {\n    const resetPassModal = document.getElementById('resetPassModal');\n    resetPassModal.style.display = \"none\";\n    document.body.style.overflow = \"\";\n}\n\nfunction closeQR() {\n    const qrModal = document.getElementById('qrModal');\n    const qrcodeContainer = document.getElementById('qrcode-container');\n    qrModal.style.display = \"none\";\n    qrcodeContainer.lastElementChild.remove();\n}\n\nfunction darkModeToggle() {\n    const isDarkMode = document.body.classList.toggle('dark-mode');\n    localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');\n}\n\nasync function getIpDetails(ip) {\n    try {\n        const response = await fetch('/panel/my-ip', { method: 'POST', body: ip });\n        const data = await response.json();\n        const { success, status, message, body } = data;\n\n        if (!success) {\n            throw new Error(`status ${status} - ${message}`);\n        }\n\n        return body;\n    } catch (error) {\n        console.error(\"Fetching IP error:\", error.message || error)\n    }\n}\n\nasync function fetchIPInfo() {\n    const refreshIcon = document.getElementById(\"refresh-geo-location\").querySelector('i');\n    refreshIcon.classList.add('fa-spin');\n    const updateUI = (ip = '-', country = '-', countryCode = '-', city = '-', isp = '-', cfIP) => {\n        const flag = countryCode !== '-' ? String.fromCodePoint(...[...countryCode].map(c => 0x1F1E6 + c.charCodeAt(0) - 65)) : '';\n        const updateContent = (id, content) => document.getElementById(id).textContent = content;\n        updateContent(cfIP ? 'cf-ip' : 'ip', ip);\n        updateContent(cfIP ? 'cf-country' : 'country', `${country} ${flag}`);\n        updateContent(cfIP ? 'cf-city' : 'city', city);\n        updateContent(cfIP ? 'cf-isp' : 'isp', isp);\n    };\n\n    try {\n        const response = await fetch('https://ipwho.is/' + '?nocache=' + Date.now(), { cache: \"no-store\" });\n        const { success, ip, message } = await response.json();\n\n        if (!success) {\n            throw new Error(`Fetch Other targets IP failed at ${response.url} - ${message}`);\n        }\n\n        const { country, countryCode, city, isp } = await getIpDetails(ip);\n        updateUI(ip, country, countryCode, city, isp);\n        refreshIcon.classList.remove('fa-spin');\n    } catch (error) {\n        console.error(\"Fetching IP error:\", error.message || error)\n    }\n\n    try {\n        const response = await fetch('https://ipv4.icanhazip.com/?nocache=' + Date.now(), { cache: \"no-store\" });\n\n        if (!response.ok) {\n            const errorMessage = await response.text();\n            throw new Error(`Fetch Cloudflare targets IP failed with status ${response.status} at ${response.url} - ${errorMessage}`);\n        }\n\n        const ip = await response.text();\n        const { country, countryCode, city, isp } = await getIpDetails(ip);\n        updateUI(ip, country, countryCode, city, isp, true);\n        refreshIcon.classList.remove('fa-spin');\n    } catch (error) {\n        console.error(\"Fetching IP error:\", error.message || error)\n    }\n}\n\nfunction downloadWarpConfigs(isAmnezia) {\n    const client = isAmnezia ? \"?app=amnezia\" : \"\";\n    window.location.href = \"/panel/get-warp-configs\" + client;\n}\n\nfunction generateSubUrl(path, app, tag, singboxType) {\n    const url = new URL(window.location.href);\n    url.pathname = `/sub/${path}/${globalThis.subPath}`;\n    app && url.searchParams.append('app', app);\n\n    if (tag) {\n        url.hash = `💦 ${atob('QlBC')} ${tag}`;\n    }\n\n    return singboxType\n        ? `sing-box://import-remote-profile?url=${url.href}`\n        : url.href;\n}\n\nfunction subURL(path, app, tag, singboxType) {\n    const url = generateSubUrl(path, app, tag, singboxType);\n    copyToClipboard(url);\n}\n\nasync function dlURL(path, app) {\n    const url = generateSubUrl(path, app);\n\n    try {\n        const response = await fetch(url);\n        const data = await response.text();\n\n        if (!response.ok) {\n            throw new Error(`status ${response.status} at ${response.url} - ${data}`);\n        }\n\n        downloadJSON(data, \"config.json\");\n    } catch (error) {\n        console.error(\"Download error:\", error.message || error);\n    }\n}\n\nfunction downloadJSON(data, fileName) {\n    const blob = new Blob([data], { type: 'text/plain' });\n    const link = document.createElement('a');\n    link.href = URL.createObjectURL(blob);\n    link.download = fileName;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\n\nfunction exportSettings() {\n    const form = validateSettings();\n    const data = JSON.stringify(form, null, 4);\n    const encodedData = btoa(data);\n    downloadJSON(encodedData, `${atob('QlBC')}-settings.dat`);\n}\n\nfunction importSettings() {\n    const input = document.getElementById('fileInput');\n    input.value = '';\n    input.click();\n}\n\nasync function uploadSettings(event) {\n    const file = event.target.files[0];\n    if (!file) return;\n\n    try {\n        const text = await file.text();\n        const data = atob(text);\n        const settings = JSON.parse(data);\n        updateSettings(event, settings);\n        initiatePanel(settings);\n    } catch (err) {\n        console.error('Failed to import settings:', err.message);\n    }\n}\n\nfunction openQR(path, app, tag, title, singboxType) {\n    const qrModal = document.getElementById('qrModal');\n    const qrcodeContainer = document.getElementById('qrcode-container');\n    const url = generateSubUrl(path, app, tag, singboxType);\n    let qrcodeTitle = document.getElementById(\"qrcodeTitle\");\n    qrcodeTitle.textContent = title;\n    qrModal.style.display = \"block\";\n    let qrcodeDiv = document.createElement(\"div\");\n    qrcodeDiv.className = \"qrcode\";\n    qrcodeDiv.style.padding = \"2px\";\n    qrcodeDiv.style.backgroundColor = \"#ffffff\";\n    /* global QRCode */\n    new QRCode(qrcodeDiv, {\n        text: url,\n        width: 256,\n        height: 256,\n        colorDark: \"#000000\",\n        colorLight: \"#ffffff\",\n        correctLevel: QRCode.CorrectLevel.H\n    });\n\n    qrcodeContainer.appendChild(qrcodeDiv);\n}\n\nfunction copyToClipboard(text) {\n    navigator.clipboard.writeText(text)\n        .then(() => alert('✅ Copied to clipboard:\\n\\n' + text))\n        .catch(error => console.error('Failed to copy:', error));\n}\n\nasync function updateWarpConfigs() {\n    const confirmReset = confirm('⚠️ Are you sure?');\n    if (!confirmReset) return;\n    const refreshBtn = document.getElementById('warp-update');\n    document.body.style.cursor = 'wait';\n    refreshBtn.classList.add('fa-spin');\n\n    try {\n        const response = await fetch('/panel/update-warp', { method: 'POST', credentials: 'include' });\n        const { success, status, message } = await response.json();\n        document.body.style.cursor = 'default';\n        refreshBtn.classList.remove('fa-spin');\n\n        if (!success) {\n            alert(`⚠️ An error occured, Please try again!\\n⛔ ${message}`);\n            throw new Error(`status ${status} - ${message}`);\n        }\n\n        alert('✅ Warp configs updated successfully!');\n    } catch (error) {\n        console.error(\"Updating Warp configs error:\", error.message || error)\n    }\n}\n\nfunction handleProtocolChange(event) {\n    if (event.target.checked) {\n        globalThis.activeProtocols++;\n        return true;\n    }\n\n    globalThis.activeProtocols--;\n\n    if (globalThis.activeProtocols === 0) {\n        event.preventDefault();\n        event.target.checked = !event.target.checked;\n        alert(\"⛔ At least one Protocol should be selected!\");\n        globalThis.activeProtocols++;\n        return false;\n    }\n}\n\nfunction handlePortChange(event) {\n    const portField = Number(event.target.name);\n\n    if (event.target.checked) {\n        globalThis.activeTlsPorts.push(portField);\n        return true;\n    }\n\n    globalThis.activeTlsPorts = globalThis.activeTlsPorts.filter(port => port !== portField);\n\n    if (globalThis.activeTlsPorts.length === 0) {\n        event.preventDefault();\n        event.target.checked = !event.target.checked;\n        alert(\"⛔ At least one TLS port should be selected!\");\n        globalThis.activeTlsPorts.push(portField);\n        return false;\n    }\n}\n\nfunction handleFragmentMode() {\n    const fragmentMode = document.getElementById(\"fragmentMode\").value;\n    const formDataObj = Object.fromEntries(globalThis.initialFormData.entries());\n    const inputs = [\n        \"fragmentLengthMin\",\n        \"fragmentLengthMax\",\n        \"fragmentIntervalMin\",\n        \"fragmentIntervalMax\"\n    ];\n\n    const configs = {\n        low: [100, 200, 1, 1],\n        medium: [50, 100, 1, 5],\n        high: [10, 20, 10, 20],\n        custom: inputs.map(id => formDataObj[id])\n    };\n\n    inputs.forEach((id, index) => {\n        const elm = document.getElementById(id);\n        elm.value = configs[fragmentMode][index];\n        fragmentMode !== \"custom\"\n            ? elm.setAttribute('readonly', 'true')\n            : elm.removeAttribute('readonly');\n    });\n}\n\nfunction resetSettings() {\n    const confirmReset = confirm('⚠️ This will reset all panel settings.\\n\\n❓ Are you sure?');\n    if (!confirmReset) return;\n\n    const resetBtn = document.getElementById(\"refresh-btn\");\n    resetBtn.classList.add('fa-spin');\n    const body = { resetSettings: true };\n    document.body.style.cursor = 'wait';\n\n    fetch('/panel/reset-settings', {\n        method: 'POST',\n        body: JSON.stringify(body),\n        credentials: 'include',\n        headers: { 'Content-Type': 'application/json' }\n    })\n        .then(response => response.json())\n        .then(({ success, status, message, body }) => {\n            document.body.style.cursor = 'default';\n            resetBtn.classList.remove('fa-spin');\n\n            if (!success) {\n                throw new Error(`status ${status} - ${message}`);\n            }\n\n            initiatePanel(body);\n            alert('✅ Panel settings reset to default successfully!\\n💡 Please update your subscriptions.');\n        })\n        .catch(error => console.error(\"Reseting settings error:\", error.message || error));\n}\n\nfunction validateSettings() {\n    const configForm = document.getElementById('configForm');\n    const formData = new FormData(configForm);\n\n    const xrayUdpNoises = [];\n    const fields = [\n        'udpXrayNoiseMode',\n        'udpXrayNoisePacket',\n        'udpXrayNoiseDelayMin',\n        'udpXrayNoiseDelayMax',\n        'udpXrayNoiseCount'\n    ].map(field => formData.getAll(field));\n\n    const validations = [\n        validateRemoteDNS(),\n        validateSanctionDns(),\n        validateLocalDNS(),\n        validateMultipleHostNames(),\n        validateProxyIPs(),\n        validateNAT64Prefixes(),\n        validateWarpEndpoints(),\n        validateMinMax(),\n        validateChainProxy(),\n        validateCustomCdn(),\n        validateKnockerNoise(),\n        validateXrayNoises(fields),\n        validateCustomRules()\n    ];\n\n    if (!validations.every(Boolean)) {\n        return false;\n    }\n\n    const form = Object.fromEntries(formData.entries());\n    const [modes, packets, delaysMin, delaysMax, counts] = fields;\n\n    modes.forEach((mode, index) => {\n        xrayUdpNoises.push({\n            type: mode,\n            packet: packets[index],\n            delay: `${delaysMin[index]}-${delaysMax[index]}`,\n            count: counts[index]\n        });\n    });\n\n    form.xrayUdpNoises = xrayUdpNoises;\n    const ports = [\n        ...defaultHttpPorts,\n        ...defaultHttpsPorts\n    ];\n\n    form.ports = ports.reduce((acc, port) => {\n        formData.has(port.toString()) && acc.push(port);\n        return acc;\n    }, []);\n\n    checkboxElements.forEach(elm => {\n        form[elm.id] = formData.has(elm.id);\n    });\n\n    selectElements.forEach(elm => {\n        let value = form[elm.id];\n        if (value === 'true') value = true;\n        if (value === 'false') value = false;\n        form[elm.id] = value;\n    });\n\n    inputElements.forEach(elm => {\n        if (typeof form[elm.id] === 'string') {\n            form[elm.id] = form[elm.id].trim();\n        }\n    });\n\n    numInputElements.forEach(elm => {\n        form[elm.id] = Number(form[elm.id].trim());\n    });\n\n    textareaElements.forEach(elm => {\n        const key = elm.id;\n        const value = form[key];\n        form[key] = value?.split('\\n').map(val => val.trim()).filter(Boolean) || [];\n    });\n\n    return form;\n}\n\nfunction updateSettings(event, data) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    const validatedForm = validateSettings();\n    if (!validatedForm) return false;\n\n    const form = data ? data : validatedForm;\n    const applyButton = document.getElementById('applyButton');\n    document.body.style.cursor = 'wait';\n    const applyButtonVal = applyButton.value;\n    applyButton.value = '⌛ Loading...';\n\n    fetch('/panel/update-settings', {\n        method: 'POST',\n        body: JSON.stringify(form),\n        credentials: 'include',\n        headers: { 'Content-Type': 'application/json' }\n    })\n        .then(response => response.json())\n        .then(({ success, status, message }) => {\n\n            if (status === 401) {\n                alert('⚠️ Session expired! Please login again.');\n                window.location.href = '/login';\n            }\n\n            if (!success) {\n                throw new Error(`status ${status} - ${message}`);\n            }\n\n            initiatePanel(form);\n            alert('✅ Settings applied successfully!\\n💡 Please update your subscriptions.');\n        })\n        .catch(error => console.error(\"Update settings error:\", error.message || error))\n        .finally(() => {\n            document.body.style.cursor = 'default';\n            applyButton.value = applyButtonVal;\n        });\n}\n\nfunction validateRemoteDNS() {\n    let url;\n    const dns = getElmValue(\"remoteDNS\");\n\n    try {\n        url = new URL(dns);\n    } catch (error) {\n        alert(\"⛔ Invalid DNS, Please enter a URL.\");\n        return false;\n    }\n\n    const cloudflareDNS = [\n        '1.1.1.1',\n        '1.0.0.1',\n        '1.1.1.2',\n        '1.0.0.2',\n        '1.1.1.3',\n        '1.0.0.3',\n        '2606:4700:4700::1111',\n        '2606:4700:4700::1001',\n        '2606:4700:4700::1112',\n        '2606:4700:4700::1002',\n        '2606:4700:4700::1113',\n        '2606:4700:4700::1003',\n        'cloudflare-dns.com',\n        'security.cloudflare-dns.com',\n        'family.cloudflare-dns.com',\n        'one.one.one.one',\n        '1dot1dot1dot1'\n    ];\n\n    if (![\"tcp:\", \"https:\", \"tls:\"].includes(url.protocol)) {\n        alert(\"⛔ Please enter TCP, DoH or DoT servers.\");\n        return false;\n    }\n\n    if (cloudflareDNS.includes(url.hostname)) {\n        alert(\"⛔ Cloudflare DNS is not allowed for workers.\\n💡 Please use other public DNS servers like Google, Adguard...\");\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateSanctionDns() {\n    const dns = getElmValue(\"antiSanctionDNS\");\n    let host;\n\n    try {\n        const url = new URL(dns);\n        host = url.hostname;\n    } catch {\n        host = dns;\n    }\n\n    const isValid = isValidHostName(host, false);\n\n    if (!isValid) {\n        alert(`⛔ Invalid IPs or Domains.\\n⚠️ ${host}`);\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateLocalDNS() {\n    const dns = getElmValue(\"localDNS\");\n    const isValid = ipv4Regex.test(dns) || dns === 'localhost';\n\n    if (!isValid) {\n        alert(`⛔ Invalid local DNS.\\n💡 Please fill in an IPv4 address or \"localhost\".\\n\\n⚠️ ${dns}`);\n        return false;\n    }\n\n    return true;\n}\n\nfunction parseElmValues(id) {\n    return document.getElementById(id).value?.split('\\n')\n        .map(value => value.trim())\n        .filter(Boolean) || [];\n}\n\nfunction getElmValue(id) {\n    return document.getElementById(id).value?.trim();\n}\n\nfunction parseHostPort(input) {\n    const regex = /^(?<host>\\[.*?\\]|[^:]+)(?::(?<port>\\d+))?$/;\n    const match = input.match(regex);\n\n    if (!match) return null;\n\n    return {\n        host: match.groups.host,\n        port: match.groups.port ? +match.groups.port : null\n    };\n}\n\nfunction isValidHostName(value, isHost) {\n    const hostPort = parseHostPort(value.trim());\n    if (!hostPort) return false;\n    const { host, port } = hostPort;\n    if (port && (port > 65535 || port < 1)) return false;\n    if (isHost && !port) return false;\n\n    return ipv6Regex.test(host) || ipv4Regex.test(host) || domainRegex.test(host);\n}\n\nfunction validateCustomRules() {\n    const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)(?:\\/(?:[0-9]|[1-2][0-9]|3[0-2]))?$/;\n    const ipv6CidrRegex = /^(?:(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,7}:|(?:[a-fA-F0-9]{1,4}:){1,6}:[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,5}(?::[a-fA-F0-9]{1,4}){1,2}|(?:[a-fA-F0-9]{1,4}:){1,4}(?::[a-fA-F0-9]{1,4}){1,3}|(?:[a-fA-F0-9]{1,4}:){1,3}(?::[a-fA-F0-9]{1,4}){1,4}|(?:[a-fA-F0-9]{1,4}:){1,2}(?::[a-fA-F0-9]{1,4}){1,5}|[a-fA-F0-9]{1,4}:(?::[a-fA-F0-9]{1,4}){1,6}|:(?::[a-fA-F0-9]{1,4}){1,7}|::)(?:\\/(?:12[0-8]|1[01]?[0-9]|[0-9]?[0-9]))?$/;\n    const invalidValues = [\n        'customBypassRules',\n        'customBlockRules',\n        'customBypassSanctionRules'\n    ].flatMap(parseElmValues)\n        .filter(value => !ipv4CidrRegex.test(value) && !ipv6CidrRegex.test(value) && !domainRegex.test(value));\n\n    if (invalidValues.length) {\n        alert('⛔ Invalid IPs, Domains or IP ranges.\\n💡 Please enter each value in a new line.\\n\\n' + invalidValues.map(ip => `⚠️ ${ip}`).join('\\n'));\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateMultipleHostNames() {\n    const invalidValues = [\n        'cleanIPs',\n        'customCdnAddrs',\n        'customCdnSni',\n        'customCdnHost'\n    ].flatMap(parseElmValues)\n        .filter(value => !isValidHostName(value));\n\n    if (invalidValues.length) {\n        alert('⛔ Invalid IPs or Domains.\\n💡 Please enter each value in a new line.\\n\\n' + invalidValues.map(ip => `⚠️ ${ip}`).join('\\n'));\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateProxyIPs() {\n    const invalidValues = parseElmValues('proxyIPs')\n        .filter(value => !isValidHostName(value));\n\n    if (invalidValues.length) {\n        alert('⛔ Invalid proxy IPs.\\n💡 Please enter each value in a new line.\\n\\n' + invalidValues.map(ip => `⚠️ ${ip}`).join('\\n'));\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateNAT64Prefixes() {\n    const invalidValues = parseElmValues('prefixes')\n        .filter(value => !ipv6Regex.test(value));\n\n    if (invalidValues.length) {\n        alert('⛔ Invalid NAT64 prefix.\\n💡 Please enter each prefix in a new line using [].\\n\\n' + invalidValues.map(ip => `⚠️ ${ip}`).join('\\n'));\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateWarpEndpoints() {\n    const invalidEndpoints = parseElmValues('warpEndpoints')\n        .filter(value => !isValidHostName(value, true));\n\n    if (invalidEndpoints.length) {\n        alert('⛔ Invalid endpoint.\\n\\n' + invalidEndpoints.map(endpoint => `⚠️ ${endpoint}`).join('\\n'));\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateMinMax() {\n    const getValue = (id) => parseInt(getElmValue(id), 10);\n    const [\n        fragmentLengthMin, fragmentLengthMax,\n        fragmentIntervalMin, fragmentIntervalMax,\n        noiseCountMin, noiseCountMax,\n        noiseSizeMin, noiseSizeMax,\n        noiseDelayMin, noiseDelayMax,\n\n    ] = [\n        'fragmentLengthMin', 'fragmentLengthMax',\n        'fragmentIntervalMin', 'fragmentIntervalMax',\n        'noiseCountMin', 'noiseCountMax',\n        'noiseSizeMin', 'noiseSizeMax',\n        'noiseDelayMin', 'noiseDelayMax'\n    ].map(getValue);\n\n    if (fragmentLengthMin >= fragmentLengthMax ||\n        fragmentIntervalMin > fragmentIntervalMax ||\n        noiseCountMin > noiseCountMax ||\n        noiseSizeMin > noiseSizeMax ||\n        noiseDelayMin > noiseDelayMax\n    ) {\n        alert('⛔ Minimum should be smaller or equal to Maximum!');\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateChainProxy() {\n    const chainProxy = getElmValue('outProxy');\n    const isVless = /vless:\\/\\/[^\\s@]+@[^\\s:]+:[^\\s]+/.test(chainProxy);\n    const isTrojan = /trojan:\\/\\/[^\\s@]+@[^\\s:]+:[^\\s]+/.test(chainProxy);\n    const isShadowsocks = /ss:\\/\\/[^\\s@]+@[^\\s:]+:[^\\s]+/.test(chainProxy);\n    const hasSecurity = /security=/.test(chainProxy);\n    const isSocksHttp = /^(http|socks):\\/\\/(?:([^:@]+):([^:@]+)@)?([^:@]+):(\\d+)$/.test(chainProxy);\n    const securityRegex = /security=(tls|none|reality)/;\n    const validSecurityType = securityRegex.test(chainProxy);\n    const validTransmission = /type=(tcp|grpc|ws)/.test(chainProxy);\n\n    if (!((isVless || isTrojan) && (hasSecurity && validSecurityType || !hasSecurity) && validTransmission) && !isShadowsocks && !isSocksHttp && chainProxy) {\n        alert('⛔ Invalid Config!\\n💡 The chain proxy should be VLESS, Trojan, Shadowsocks, Socks or Http!\\n💡 VLESS, Trojan and Shadowsocks transmission should be GRPC,WS or TCP\\n💡 VLESS, Trojan and Shadowsocks security should be TLS, Reality or None\\n💡 Socks or http should be like:\\n + (socks or http)://user:pass@host:port\\n + (socks or http)://host:port');\n        return false;\n    }\n\n    let match = chainProxy.match(securityRegex);\n    const securityType = match?.[1] || null;\n    match = chainProxy.match(/:(\\d+)\\?/);\n    const vlessPort = match?.[1] || null;\n\n    if ((isVless || isTrojan) && securityType === 'tls' && vlessPort !== '443') {\n        alert('⛔ VLESS TLS port can be only 443 to be used as a proxy chain!');\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateCustomCdn() {\n    const customCdnHost = getElmValue('customCdnHost');\n    const customCdnSni = getElmValue('customCdnSni');\n    const customCdnAddrs = parseElmValues('customCdnAddrs');\n    const isCustomCdn = customCdnAddrs.length || customCdnHost !== '' || customCdnSni !== '';\n\n    if (isCustomCdn && !(customCdnAddrs.length && customCdnHost && customCdnSni)) {\n        alert('⛔ All \"Custom\" fields should be filled or deleted together!');\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateKnockerNoise() {\n    const regex = /^(none|quic|random|[0-9A-Fa-f]+)$/;\n    const knockerNoise = getElmValue(\"knockerNoiseMode\");\n\n    if (!regex.test(knockerNoise)) {\n        alert('⛔ Invalid noise  mode.\\n💡 Please use \"none\", \"quic\", \"random\" or a valid hex value.');\n        return false;\n    }\n\n    return true;\n}\n\nfunction validateXrayNoises(fields) {\n    const [modes, packets, delaysMin, delaysMax] = fields;\n    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\n    let submisionError = false;\n\n    modes.forEach((mode, index) => {\n        if (Number(delaysMin[index]) > Number(delaysMax[index])) {\n            alert('⛔ The minimum noise delay should be smaller or equal to maximum!');\n            submisionError = true;\n            return;\n        }\n\n        switch (mode) {\n            case 'base64': {\n                if (!base64Regex.test(packets[index])) {\n                    alert('⛔ The Base64 noise packet is not a valid base64 value!');\n                    submisionError = true;\n                }\n\n                break;\n            }\n            case 'rand': {\n                if (!(/^\\d+-\\d+$/.test(packets[index]))) {\n                    alert('⛔ The Random noise packet should be a range like 0-10 or 10-30!');\n                    submisionError = true;\n                }\n\n                const [min, max] = packets[index].split(\"-\").map(Number);\n\n                if (min > max) {\n                    alert('⛔ The minimum Random noise packet should be smaller or equal to maximum!');\n                    submisionError = true;\n                }\n\n                break;\n            }\n            case 'hex': {\n                if (!(/^(?=(?:[0-9A-Fa-f]{2})*$)[0-9A-Fa-f]+$/.test(packets[index]))) {\n                    alert('⛔ The Hex noise packet is not a valid hex value! It should have even length and consisted of 0-9, a-f and A-F.');\n                    submisionError = true;\n                }\n\n                break;\n            }\n        }\n    });\n\n    return !submisionError;\n}\n\nfunction logout(event) {\n    event.preventDefault();\n    fetch('/logout', { method: 'GET', credentials: 'same-origin' })\n        .then(response => response.json())\n        .then(({ success, status, message }) => {\n            if (!success) {\n                throw new Error(`status ${status} - ${message}`);\n            }\n\n            window.location.href = '/login';\n        })\n        .catch(error => console.error(\"Logout error:\", error.message || error));\n}\n\ndocument.querySelectorAll(\".toggle-password\").forEach(toggle => {\n    toggle.addEventListener(\"click\", function () {\n        const input = this.previousElementSibling;\n        const isPassword = input.type === \"password\";\n        input.type = isPassword ? \"text\" : \"password\";\n        this.textContent = isPassword ? \"visibility\" : \"visibility_off\";\n    });\n});\n\nfunction resetPassword(event) {\n    event.preventDefault();\n    const resetPassModal = document.getElementById('resetPassModal');\n    const newPasswordInput = document.getElementById('newPassword');\n    const confirmPasswordInput = document.getElementById('confirmPassword');\n    const passwordError = document.getElementById('passwordError');\n    const newPassword = newPasswordInput.value;\n    const confirmPassword = confirmPasswordInput.value;\n\n    if (newPassword !== confirmPassword) {\n        passwordError.textContent = \"Passwords do not match\";\n        return false;\n    }\n\n    const hasCapitalLetter = /[A-Z]/.test(newPassword);\n    const hasNumber = /[0-9]/.test(newPassword);\n    const isLongEnough = newPassword.length >= 8;\n\n    if (!(hasCapitalLetter && hasNumber && isLongEnough)) {\n        passwordError.textContent = '⚠️ Password must contain at least one capital letter, one number, and be at least 8 characters long.';\n        return false;\n    }\n\n    fetch('/panel/reset-password', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'text/plain'\n        },\n        body: newPassword,\n        credentials: 'same-origin'\n    })\n        .then(response => response.json())\n        .then(({ success, status, message }) => {\n            if (!success) {\n                passwordError.textContent = `⚠️ ${message}`;\n                throw new Error(`status ${status} - ${message}`);\n            }\n\n            alert(\"✅ Password changed successfully! 👍\");\n            window.location.href = '/login';\n\n        })\n        .catch(error => console.error(\"Reset password error:\", error.message || error))\n        .finally(() => {\n            resetPassModal.style.display = \"none\";\n            document.body.style.overflow = \"\";\n        });\n}\n\nfunction renderPortsBlock(ports) {\n    let noneTlsPortsBlock = '', tlsPortsBlock = '';\n    const totalPorts = [\n        ...(window.origin.includes('workers.dev') ? defaultHttpPorts : []),\n        ...defaultHttpsPorts\n    ];\n\n    totalPorts.forEach(port => {\n        const isChecked = ports.includes(port) ? 'checked' : '';\n        let clss = '', handler = '';\n\n        if (defaultHttpsPorts.includes(port)) {\n            clss = 'class=\"https\"';\n            handler = 'onclick=\"handlePortChange(event)\"';\n        }\n\n        const portBlock = `\n            <div class=\"routing\">\n                <input type=\"checkbox\" name=${port} ${clss} value=\"true\" ${isChecked} ${handler}>\n                <label>${port}</label>\n            </div>`;\n\n        defaultHttpsPorts.includes(port)\n            ? tlsPortsBlock += portBlock\n            : noneTlsPortsBlock += portBlock;\n    });\n\n    document.getElementById(\"tls-ports\").innerHTML = tlsPortsBlock;\n\n    if (noneTlsPortsBlock) {\n        document.getElementById(\"non-tls-ports\").innerHTML = noneTlsPortsBlock;\n        document.getElementById(\"none-tls\").style.display = 'flex';\n    }\n}\n\nfunction addUdpNoise(isManual, noiseIndex, udpNoise) {\n    const index = noiseIndex ?? globalThis.xrayNoiseCount;\n    const noise = udpNoise || {\n        type: 'rand',\n        packet: '50-100',\n        delay: '1-5',\n        count: 5\n    };\n\n    const container = document.createElement('div');\n    container.className = \"inner-container\";\n    container.id = `udp-noise-${index + 1}`;\n\n    container.innerHTML = `\n        <div class=\"header-container\">\n            <h4>Noise ${index + 1}</h4>\n            <button type=\"button\" class=\"delete-noise\">\n                <span class=\"material-symbols-rounded\">delete</span>\n            </button>      \n        </div>\n        <div class=\"section\">\n            <div class=\"form-control\">\n                <label>😵‍💫 Mode</label>\n                <div>\n                    <select name=\"udpXrayNoiseMode\">\n                        <option value=\"base64\" ${noise.type === 'base64' ? 'selected' : ''}>Base64</option>\n                        <option value=\"rand\" ${noise.type === 'rand' ? 'selected' : ''}>Random</option>\n                        <option value=\"str\" ${noise.type === 'str' ? 'selected' : ''}>String</option>\n                        <option value=\"hex\" ${noise.type === 'hex' ? 'selected' : ''}>Hex</option>\n                    </select>\n                </div>\n            </div>\n            <div class=\"form-control\">\n                <label>📥 Packet</label>\n                <div>\n                    <input type=\"text\" name=\"udpXrayNoisePacket\" value=\"${noise.packet}\">\n                </div>\n            </div>\n            <div class=\"form-control\">\n                <label>🎚️ Count</label>\n                <div>\n                    <input type=\"number\" name=\"udpXrayNoiseCount\" value=\"${noise.count}\" min=\"1\" required>\n                </div>\n            </div>\n            <div class=\"form-control\">\n                <label>🕞 Delay</label>\n                <div class=\"min-max\">\n                    <input type=\"number\" name=\"udpXrayNoiseDelayMin\"\n                        value=\"${noise.delay.split('-')[0]}\" min=\"1\" required>\n                    <span> - </span>\n                    <input type=\"number\" name=\"udpXrayNoiseDelayMax\"\n                        value=\"${noise.delay.split('-')[1]}\" min=\"1\" required>\n                </div>\n            </div>\n        </div>`;\n\n    container.querySelector(\".delete-noise\").addEventListener('click', deleteUdpNoise);\n    container.querySelector(\"select\").addEventListener('change', generateUdpNoise);\n\n    document.getElementById(\"noises\").append(container);\n    if (isManual) enableApplyButton();\n    globalThis.xrayNoiseCount++;\n}\n\nfunction generateUdpNoise(event) {\n    const generateRandomBase64 = length => {\n        const array = new Uint8Array(Math.ceil(length * 3 / 4));\n        crypto.getRandomValues(array);\n        let base64 = btoa(String.fromCharCode(...array));\n\n        return base64.slice(0, length);\n    }\n\n    const generateRandomHex = length => {\n        const array = new Uint8Array(Math.ceil(length / 2));\n        crypto.getRandomValues(array);\n        let hex = [...array].map(b => b.toString(16).padStart(2, '0')).join('');\n\n        return hex.slice(0, length);\n    }\n\n    const generateRandomString = length => {\n        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        const array = new Uint8Array(length);\n\n        return Array.from(crypto.getRandomValues(array), x => chars[x % chars.length]).join('');\n    };\n\n    const noisePacket = event.target.closest(\".inner-container\").querySelector('[name=\"udpXrayNoisePacket\"]');\n\n    switch (event.target.value) {\n        case 'base64':\n            noisePacket.value = generateRandomBase64(64);\n            break;\n\n        case 'rand':\n            noisePacket.value = \"50-100\";\n            break;\n\n        case 'hex':\n            noisePacket.value = generateRandomHex(64);\n            break;\n\n        case 'str':\n            noisePacket.value = generateRandomString(64);\n            break;\n    }\n}\n\nfunction deleteUdpNoise(event) {\n    if (globalThis.xrayNoiseCount === 1) {\n        alert('⛔ You cannot delete all noises!');\n        return;\n    }\n\n    const confirmReset = confirm('⚠️ This will delete the noise.\\n\\n❓ Are you sure?');\n    if (!confirmReset) return;\n    event.target.closest(\".inner-container\").remove();\n    enableApplyButton();\n    globalThis.xrayNoiseCount--;\n}\n\nfunction renderUdpNoiseBlock(xrayUdpNoises) {\n    document.getElementById(\"noises\").innerHTML = '';\n    xrayUdpNoises.forEach((noise, index) => {\n        addUdpNoise(false, index, noise);\n    });\n\n    globalThis.xrayNoiseCount = xrayUdpNoises.length;\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/assets/secrets/script.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'localStorage' is not defined.","line":1,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":1,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":1,"endColumn":59},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":6,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":6,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":14,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":11},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":17,"column":29,"nodeType":"MemberExpression","endLine":17,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":26,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":11},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":29,"column":28,"nodeType":"MemberExpression","endLine":29,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":39,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":40,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":41,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'window' is not defined.","line":44,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":44,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'document' is not defined.","line":46,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":46,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'navigator' is not defined.","line":49,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":49,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'alert' is not defined.","line":50,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":50,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":51,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":30}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"localStorage.getItem('darkMode') === 'enabled' && document.body.classList.add('dark-mode');\ngenerateCredentials();\nlet uuid, password, uriPath;\n\nfunction generateUUID() {\n    return crypto.randomUUID();\n}\n\nfunction generateStrongPassword() {\n    const charset =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+[]{}|;:',.<>?\";\n    let password = '';\n    const randomValues = new Uint8Array(16);\n    crypto.getRandomValues(randomValues);\n\n    for (let i = 0; i < 16; i++) {\n        password += charset[randomValues[i] % charset.length];\n    }\n    return password;\n}\n\nfunction generateSubURIPath() {\n    const charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@$&*_-+;:,.\";\n    let uriPath = '';\n    const randomValues = new Uint8Array(16);\n    crypto.getRandomValues(randomValues);\n\n    for (let i = 0; i < 16; i++) {\n        uriPath += charset[randomValues[i] % charset.length];\n    }\n    return uriPath;\n}\n\nfunction generateCredentials() {\n    uuid = generateUUID();\n    password = generateStrongPassword();\n    uriPath = generateSubURIPath();\n\n    document.getElementById('uuid').textContent = uuid;\n    document.getElementById('tr-password').textContent = password;\n    document.getElementById('sub-path').textContent = uriPath;\n}\n\nwindow.copyToClipboard = function (elementId) {\n    const textToCopy = elementId \n        ? document.getElementById(elementId).textContent\n        : `UUID=${uuid}\\nTR_PASS=${password}\\nSUB_PATH=${uriPath}`;\n\n    navigator.clipboard.writeText(textToCopy)\n        .then(() => alert('✅ Copied to clipboard!'))\n        .catch(err => console.error('Failed to copy text:', err));\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/auth.js","messages":[{"ruleId":"security/detect-possible-timing-attacks","severity":1,"message":"Potential timing attack, left side: true","line":13,"column":5,"nodeType":"IfStatement","endLine":15,"endColumn":6},{"ruleId":"no-undef","severity":2,"message":"'TextEncoder' is not defined.","line":24,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":39,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'TextEncoder' is not defined.","line":47,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":47,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":52,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":52,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":57,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":60,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":60,"endColumn":16}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { SignJWT, jwtVerify } from 'jose';\nimport { respond } from '#common/handlers';\nimport { globalConfig } from '#common/init';\n\nexport async function generateJWTToken(request, env) {\n    if (request.method !== 'POST') {\n        return await respond(false, 405, 'Method not allowed.');\n    }\n\n    const password = await request.text();\n    const savedPass = await env.kv.get('pwd');\n    \n    if (password !== savedPass) {\n        return await respond(false, 401, 'Wrong password.');\n    }\n\n    let secretKey = await env.kv.get('secretKey');\n\n    if (!secretKey) {\n        secretKey = generateSecretKey();\n        await env.kv.put('secretKey', secretKey);\n    }\n    \n    const secret = new TextEncoder().encode(secretKey);\n    const jwtToken = await new SignJWT({ userID: globalConfig.userID })\n        .setProtectedHeader({ alg: 'HS256' })\n        .setIssuedAt()\n        .setExpirationTime('24h')\n        .sign(secret);\n\n    return await respond(true, 200, 'Successfully generated Auth token', null, {\n        'Set-Cookie': `jwtToken=${jwtToken}; HttpOnly; Secure; Max-Age=${7 * 24 * 60 * 60}; Path=/; SameSite=Strict`,\n        'Content-Type': 'text/plain',\n    });\n}\n\nfunction generateSecretKey() {\n    const array = new Uint8Array(32);\n    crypto.getRandomValues(array);\n    \n    return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\nexport async function Authenticate(request, env) {\n    try {\n        const secretKey = await env.kv.get('secretKey');\n        const secret = new TextEncoder().encode(secretKey);\n        const cookie = request.headers.get('Cookie')?.match(/(^|;\\s*)jwtToken=([^;]*)/);\n        const token = cookie ? cookie[2] : null;\n\n        if (!token) {\n            console.log('Unauthorized: Token not available!');\n            return false;\n        }\n\n        const { payload } = await jwtVerify(token, secret);\n        console.log(`Successfully authenticated, User ID: ${payload.userID}`);\n        return true;\n    } catch (error) {\n        console.log(error);\n        return false;\n    }\n}\n\nexport async function logout() {\n    return await respond(true, 200, 'Successfully logged out!', null, {\n        'Set-Cookie': 'jwtToken=; Secure; SameSite=None; Expires=Thu, 01 Jan 1970 00:00:00 GMT',\n        'Content-Type': 'text/plain'\n    });\n}\n\nexport async function resetPassword(request, env) {\n    let auth = await Authenticate(request, env);\n    const oldPwd = await env.kv.get('pwd');\n    \n    if (oldPwd && !auth) {\n        return await respond(false, 401, 'Unauthorized.');\n    }\n\n    const newPwd = await request.text();\n    if (newPwd === oldPwd) {\n        return await respond(false, 400, 'Please enter a new Password.');\n    }\n\n    await env.kv.put('pwd', newPwd);\n    \n    return await respond(true, 200, 'Successfully logged in!', null, {\n        'Set-Cookie': 'jwtToken=; Path=/; Secure; SameSite=None; Expires=Thu, 01 Jan 1970 00:00:00 GMT',\n        'Content-Type': 'text/plain',\n    });\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/common/handlers.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":18,"column":57,"nodeType":"Identifier","messageId":"undef","endLine":18,"endColumn":61},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":35,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":35,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":36,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'__ERROR_HTML_CONTENT__' is not defined.","line":65,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":67,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":24},{"ruleId":"no-fallthrough","severity":2,"message":"Expected a 'break' statement before 'case'.","line":104,"column":9,"nodeType":"SwitchCase","messageId":"case","endLine":112,"endColumn":14},{"ruleId":"no-fallthrough","severity":2,"message":"Expected a 'break' statement before 'case'.","line":114,"column":9,"nodeType":"SwitchCase","messageId":"case","endLine":124,"endColumn":14},{"ruleId":"no-fallthrough","severity":2,"message":"Expected a 'break' statement before 'case'.","line":126,"column":9,"nodeType":"SwitchCase","messageId":"case","endLine":136,"endColumn":14},{"ruleId":"no-fallthrough","severity":2,"message":"Expected a 'break' statement before 'default'.","line":138,"column":9,"nodeType":"SwitchCase","messageId":"default","endLine":139,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":193,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":193,"endColumn":27},{"ruleId":"no-undef","severity":2,"message":"'Request' is not defined.","line":196,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":196,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":203,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":203,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":210,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":210,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":215,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":215,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":225,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":225,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":249,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":249,"endColumn":29},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":267,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":267,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":270,"column":65,"nodeType":"Identifier","messageId":"undef","endLine":270,"endColumn":69},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":274,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":274,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'__ICON__' is not defined.","line":279,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":279,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":280,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":280,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":282,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":282,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":297,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":297,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'__PANEL_HTML_CONTENT__' is not defined.","line":301,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":301,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":303,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":303,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":311,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":311,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'__LOGIN_HTML_CONTENT__' is not defined.","line":314,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":314,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":316,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":316,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'__SECRETS_HTML_CONTENT__' is not defined.","line":322,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":322,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":324,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":324,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":341,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":341,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":350,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":350,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'TextDecoder' is not defined.","line":364,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":364,"endColumn":36}],"suppressedMessages":[],"errorCount":33,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Authenticate, generateJWTToken, resetPassword } from \"#auth\";\nimport { getClNormalConfig, getClWarpConfig } from \"#configs/clash\";\nimport { getSbCustomConfig, getSbWarpConfig } from \"#configs/sing-box\";\nimport { getXrCustomConfigs, getXrWarpConfigs } from \"#configs/xray\";\nimport { extractWireguardParams } from \"#configs/utils\";\nimport { getDataset, updateDataset } from \"#kv\";\nimport { fetchWarpConfigs } from \"#protocols/warp\";\nimport { globalConfig, httpConfig, wsConfig } from \"#common/init\";\nimport { VlOverWSHandler } from \"#protocols/websocket/vless\";\nimport { TrOverWSHandler } from \"#protocols/websocket/trojan\";\nimport JSZip from \"jszip\";\nexport let settings = {}\n\nexport async function handleWebsocket(request) {\n    const encodedPathConfig = globalConfig.pathName.replace(\"/\", \"\") || '';\n\n    try {\n        const { protocol, mode, panelIPs } = JSON.parse(atob(encodedPathConfig));\n\n        Object.assign(wsConfig, {\n            wsProtocol: protocol,\n            proxyMode: mode,\n            panelIPs: panelIPs\n        });\n\n        switch (protocol) {\n            case 'vl':\n                return await VlOverWSHandler(request);\n            case 'tr':\n                return await TrOverWSHandler(request);\n            default:\n                return await fallback(request);\n        }\n\n    } catch (error) {\n        return new Response('Failed to parse WebSocket path config', { status: 400 });\n    }\n}\n\nexport async function handlePanel(request, env) {\n\n    switch (globalConfig.pathName) {\n        case '/panel':\n            return await renderPanel(request, env);\n        case '/panel/settings':\n            return await getSettings(request, env);\n        case '/panel/update-settings':\n            return await updateSettings(request, env);\n        case '/panel/reset-settings':\n            return await resetSettings(request, env);\n        case '/panel/reset-password':\n            return await resetPassword(request, env);\n        case '/panel/my-ip':\n            return await getMyIP(request);\n        case '/panel/update-warp':\n            return await updateWarpConfigs(request, env);\n        case '/panel/get-warp-configs':\n            return await getWarpConfigs(request, env);\n        default:\n            return await fallback(request);\n    }\n}\n\nexport async function handleError(error) {\n    const html = hexToString(__ERROR_HTML_CONTENT__).replace('__ERROR_MESSAGE__', error.message);\n\n    return new Response(html, {\n        status: 200,\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\nexport async function handleLogin(request, env) {\n    if (globalConfig.pathName === '/login') {\n        return await renderLogin(request, env);\n    }\n\n    if (globalConfig.pathName === '/login/authenticate') {\n        return await generateJWTToken(request, env);\n    }\n\n    return await fallback(request);\n}\n\nexport async function handleSubscriptions(request, env) {\n    const dataset = await getDataset(request, env);\n    settings = dataset.settings;\n    const { client, subPath } = httpConfig;\n    const path = decodeURIComponent(globalConfig.pathName);\n\n    switch (path) {\n        case `/sub/normal/${subPath}`:\n            switch (client) {\n                case 'xray':\n                    return await getXrCustomConfigs(env, false);\n                case 'sing-box':\n                    return await getSbCustomConfig(env, false);\n                case 'clash':\n                    return await getClNormalConfig(env);\n                default:\n                    break;\n            }\n\n        case `/sub/fragment/${subPath}`:\n            switch (client) {\n                case 'xray':\n                    return await getXrCustomConfigs(env, true);\n                case 'sing-box':\n                    return await getSbCustomConfig(env, true);\n                default:\n                    break;\n            }\n\n        case `/sub/warp/${subPath}`:\n            switch (client) {\n                case 'xray':\n                    return await getXrWarpConfigs(request, env, false, false);\n                case 'sing-box':\n                    return await getSbWarpConfig(request, env);\n                case 'clash':\n                    return await getClWarpConfig(request, env, false);\n                default:\n                    break;\n            }\n\n        case `/sub/warp-pro/${subPath}`:\n            switch (client) {\n                case 'xray':\n                    return await getXrWarpConfigs(request, env, true, false);\n                case 'xray-knocker':\n                    return await getXrWarpConfigs(request, env, true, true);\n                case 'clash':\n                    return await getClWarpConfig(request, env, true);\n                default:\n                    break;\n            }\n\n        default:\n            return await fallback(request);\n    }\n}\n\nasync function updateSettings(request, env) {\n    if (request.method === 'POST') {\n        const auth = await Authenticate(request, env);\n\n        if (!auth) {\n            return await respond(false, 401, 'Unauthorized or expired session.');\n        }\n\n        const proxySettings = await updateDataset(request, env);\n        return await respond(true, 200, null, proxySettings);\n    }\n\n    return await respond(false, 405, 'Method not allowed.');\n}\n\nasync function resetSettings(request, env) {\n    if (request.method === 'POST') {\n        const auth = await Authenticate(request, env);\n\n        if (!auth) {\n            return await respond(false, 401, 'Unauthorized or expired session.');\n        }\n\n        const proxySettings = await updateDataset(request, env);\n        return await respond(true, 200, null, proxySettings);\n    }\n\n    return await respond(false, 405, 'Method not allowed!');\n}\n\nasync function getSettings(request, env) {\n    const isPassSet = await env.kv.get('pwd') ? true : false;\n    const auth = await Authenticate(request, env);\n\n    if (!auth) {\n        return await respond(false, 401, 'Unauthorized or expired session.', { isPassSet });\n    }\n\n    const dataset = await getDataset(request, env);\n    const data = {\n        proxySettings: dataset.settings,\n        isPassSet,\n        subPath: httpConfig.subPath\n    };\n\n    return await respond(true, 200, null, data);\n}\n\nexport async function fallback(request) {\n    const { url, method, headers, body } = request;\n    const newURL = new URL(url);\n    newURL.hostname = globalConfig.fallbackDomain;\n    newURL.protocol = 'https:';\n    const newRequest = new Request(newURL.toString(), {\n        method,\n        headers,\n        body,\n        redirect: 'manual'\n    });\n\n    return await fetch(newRequest);\n}\n\nasync function getMyIP(request) {\n    const ip = await request.text();\n\n    try {\n        const response = await fetch(`http://ip-api.com/json/${ip}?nocache=${Date.now()}`);\n        const geoLocation = await response.json();\n\n        return await respond(true, 200, null, geoLocation);\n    } catch (error) {\n        console.error('Error fetching IP address:', error);\n        return await respond(false, 500, `Error fetching IP address: ${error}`)\n    }\n}\n\nasync function getWarpConfigs(request, env) {\n    const isPro = httpConfig.client === 'amnezia';\n    const auth = await Authenticate(request, env);\n\n    if (!auth) {\n        return new Response('Unauthorized or expired session.', { status: 401 });\n    }\n\n    const { warpConfigs, settings } = await getDataset(request, env);\n    const warpConfig = extractWireguardParams(warpConfigs, false);\n    const { warpIPv6, publicKey, privateKey } = warpConfig;\n    const { warpEndpoints, amneziaNoiseCount, amneziaNoiseSizeMin, amneziaNoiseSizeMax } = settings;\n    const zip = new JSZip();\n    const trimLines = (string) => string.split(\"\\n\").map(line => line.trim()).join(\"\\n\");\n    const amneziaNoise = isPro\n        ?\n        `Jc = ${amneziaNoiseCount}\n        Jmin = ${amneziaNoiseSizeMin}\n        Jmax = ${amneziaNoiseSizeMax}\n        S1 = 0\n        S2 = 0\n        H1 = 0\n        H2 = 0\n        H3 = 0\n        H4 = 0`\n        : '';\n\n    try {\n        warpEndpoints.forEach((endpoint, index) => {\n            zip.file(`${atob('QlBC')}-Warp-${index + 1}.conf`, trimLines(\n                `[Interface]\n                PrivateKey = ${privateKey}\n                Address = 172.16.0.2/32, ${warpIPv6}\n                DNS = 1.1.1.1, 1.0.0.1\n                MTU = 1280\n                ${amneziaNoise}\n                [Peer]\n                PublicKey = ${publicKey}\n                AllowedIPs = 0.0.0.0/0, ::/0\n                Endpoint = ${endpoint}\n                PersistentKeepalive = 25`\n            ));\n        });\n\n        const zipBlob = await zip.generateAsync({ type: \"blob\" });\n        const arrayBuffer = await zipBlob.arrayBuffer();\n\n        return new Response(arrayBuffer, {\n            headers: {\n                \"Content-Type\": \"application/zip\",\n                \"Content-Disposition\": `attachment; filename=\"${atob('QlBC')}-Warp-${isPro ? \"Pro-\" : \"\"}configs.zip\"`,\n            },\n        });\n    } catch (error) {\n        return new Response(`Error generating ZIP file: ${error}`, { status: 500 });\n    }\n}\n\nexport async function serveIcon() {\n    const faviconBase64 = __ICON__;\n    const body = Uint8Array.from(atob(faviconBase64), c => c.charCodeAt(0));\n\n    return new Response(body, {\n        headers: {\n            'Content-Type': 'image/x-icon',\n            'Cache-Control': 'public, max-age=86400',\n        }\n    });\n}\n\nasync function renderPanel(request, env) {\n    const pwd = await env.kv.get('pwd');\n\n    if (pwd) {\n        const auth = await Authenticate(request, env);\n\n        if (!auth) {\n            return Response.redirect(`${httpConfig.urlOrigin}/login`, 302);\n        }\n    }\n\n    const html = hexToString(__PANEL_HTML_CONTENT__);\n\n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\nasync function renderLogin(request, env) {\n    const auth = await Authenticate(request, env);\n    if (auth) {\n        return Response.redirect(`${httpConfig.urlOrigin}/panel`, 302);\n    }\n\n    const html = hexToString(__LOGIN_HTML_CONTENT__);\n\n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' }\n    });\n}\n\nexport async function renderSecrets() {\n    const html = hexToString(__SECRETS_HTML_CONTENT__);\n\n    return new Response(html, {\n        headers: { 'Content-Type': 'text/html' },\n    });\n}\n\nasync function updateWarpConfigs(request, env) {\n    if (request.method === 'POST') {\n        const auth = await Authenticate(request, env);\n\n        if (!auth) {\n            return await respond(false, 401, 'Unauthorized.');\n        }\n\n        try {\n            await fetchWarpConfigs(env);\n            return await respond(true, 200, 'Warp configs updated successfully!');\n        } catch (error) {\n            console.log(error);\n            return await respond(false, 500, `An error occurred while updating Warp configs: ${error}`);\n        }\n    }\n\n    return await respond(false, 405, 'Method not allowd.');\n}\n\nexport async function respond(success, status, message, body, customHeaders) {\n    return new Response(JSON.stringify({\n        success,\n        status,\n        message: message || '',\n        body: body || ''\n    }), {\n        headers: customHeaders || {\n            'Content-Type': message ? 'text/plain' : 'application/json'\n        }\n    });\n}\n\nfunction hexToString(hex) {\n    const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));\n    const decoder = new TextDecoder();\n\n    return decoder.decode(bytes);\n}\n\nexport function isValidUUID(uuid) {\n    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n    return uuidRegex.test(uuid);\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/common/init.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":7,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":7,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":21,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":26,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":26,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":33,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":33,"endColumn":49},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":36,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":36,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":39,"column":72,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":76},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":41,"column":113,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":117},{"ruleId":"no-undef","severity":2,"message":"'__VERSION__' is not defined.","line":45,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":34}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isValidUUID } from \"#common/handlers\";\nexport const globalConfig = {};\nexport const httpConfig = {};\nexport const wsConfig = {};\n\nexport function init(request, env) {\n    const { pathname } = new URL(request.url);\n    const { UUID, TR_PASS, FALLBACK, DOH_URL } = env;\n\n    Object.assign(globalConfig, {\n        userID: UUID,\n        TrPass: TR_PASS,\n        pathName: pathname,\n        fallbackDomain: FALLBACK || 'speed.cloudflare.com',\n        dohURL: DOH_URL || 'https://cloudflare-dns.com/dns-query'\n    })\n}\n\nexport function initWs(env) {\n    Object.assign(wsConfig, {\n        defaultProxyIPs: [atob('YnBiLnlvdXNlZi5pc2VnYXJvLmNvbQ==')],\n        defaultPrefixes: [\n            'WzJhMDI6ODk4OjE0Njo2NDo6XQ==',\n            'WzI2MDI6ZmM1OTpiMDo2NDo6XQ==',\n            'WzI2MDI6ZmM1OToxMTo2NDo6XQ=='\n        ].map(atob),\n        envProxyIPs: env.PROXY_IP,\n        envPrefixes: env.PREFIX\n    });\n}\n\nexport function initHttp(request, env) {\n    const { pathname, origin, search } = new URL(request.url);\n    const { SUB_PATH, kv } = env;\n    const { userID, TrPass } = globalConfig;\n    const searchParams = new URLSearchParams(search);\n\n    if (!['/secrets', '/favicon.ico'].includes(pathname)) {\n        if (!userID || !TrPass) throw new Error(`Please set UUID and ${atob('VHJvamFu')} password first. Please visit <a href=\"${origin}/secrets\" target=\"_blank\">here</a> to generate them.`, { cause: \"init\" });\n        if (!isValidUUID(userID)) throw new Error(`Invalid UUID: ${userID}`, { cause: \"init\" });\n        if (typeof kv !== 'object') throw new Error(`KV Dataset is not properly set! Please refer to <a href=\"${atob('aHR0cHM6Ly9iaWEtcGFpbi1iYWNoZS5naXRodWIuaW8vQlBCLVdvcmtlci1QYW5lbC8=')}\" target=\"_blank\">tutorials</a>.`, { cause: \"init\" });\n    }\n\n    Object.assign(httpConfig, {\n        panelVersion: __VERSION__,\n        defaultHttpPorts: [80, 8080, 2052, 2082, 2086, 2095, 8880],\n        defaultHttpsPorts: [443, 8443, 2053, 2083, 2087, 2096],\n        hostName: request.headers.get('Host'),\n        client: searchParams.get('app'),\n        urlOrigin: origin,\n        subPath: SUB_PATH || userID\n    });\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/configs/clash.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":57,"column":13,"nodeType":"MemberExpression","endLine":57,"endColumn":64},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":144,"column":13,"nodeType":"MemberExpression","endLine":144,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":223,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":223,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":260,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":260,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":333,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":333,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":338,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":338,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":339,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":339,"endColumn":36},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":345,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":345,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":349,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":349,"endColumn":32},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":359,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":359,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":365,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":365,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":414,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":414,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":415,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":415,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":538,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":538,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":539,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":539,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":558,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":558,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":562,"column":34,"nodeType":"Identifier","messageId":"undef","endLine":562,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":573,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":573,"endColumn":52},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":590,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":590,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":624,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":624,"endColumn":24}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDataset } from '#kv';\nimport { globalConfig, httpConfig } from '#common/init';\nimport { settings } from '#common/handlers'\nimport {\n    getConfigAddresses,\n    extractWireguardParams,\n    generateRemark,\n    randomUpperCase,\n    isIPv6,\n    isIPv4,\n    isDomain,\n    isHttps,\n    getDomain,\n    generateWsPath,\n    parseHostPort,\n    parseChainProxy\n} from '#configs/utils';\n\nasync function buildDNS(isChain, isWarp, isPro) {\n    const finalLocalDNS = settings.localDNS === 'localhost' ? 'system' : `${settings.localDNS}#DIRECT`;\n    const isIPv6 = (settings.VLTRenableIPv6 && !isWarp) || (settings.warpEnableIPv6 && isWarp);\n    const remoteDnsDetour = isWarp\n        ? `💦 Warp ${isPro ? 'Pro ' : ''}- Best Ping 🚀`\n        : isChain ? '💦 Best Ping 🚀' : '✅ Selector';\n\n    const dnsObject = {\n        \"enable\": true,\n        \"listen\": \"0.0.0.0:1053\",\n        \"ipv6\": isIPv6,\n        \"respect-rules\": true,\n        \"use-system-hosts\": false,\n        \"nameserver\": [`${isWarp ? '1.1.1.1' : settings.remoteDNS}#${remoteDnsDetour}`],\n        \"proxy-server-nameserver\": [finalLocalDNS],\n        \"nameserver-policy\": {\n            \"raw.githubusercontent.com\": finalLocalDNS,\n            \"time.cloudflare.com\": finalLocalDNS\n        }\n    };\n\n    if (settings.dohHost.isDomain && !isWarp) {\n        const { ipv4, ipv6, host } = settings.dohHost;\n        dnsObject[\"hosts\"] = {\n            [host]: settings.VLTRenableIPv6 ? [...ipv4, ...ipv6] : ipv4\n        }\n    }\n\n    const antiSanctionDnsHost = getDomain(settings.antiSanctionDNS);\n\n    if (antiSanctionDnsHost.isHostDomain) {\n        dnsObject[\"nameserver-policy\"][antiSanctionDnsHost.host] = finalLocalDNS;\n    }\n\n    if (isChain && !isWarp) {\n        const chainOutboundServer = settings.outProxyParams.server;\n\n        if (isDomain(chainOutboundServer)) {\n            dnsObject[\"nameserver-policy\"][chainOutboundServer] = `${settings.remoteDNS}#${remoteDnsDetour}`;\n        }\n    }\n\n    const routingRules = getRuleProviders();\n\n    settings.customBlockRules.forEach(value => {\n        if (isDomain(value)) {\n            if (!dnsObject[\"hosts\"]) dnsObject[\"hosts\"] = {};\n            dnsObject[\"hosts\"][`+.${value}`] = \"rcode://refused\";\n        }\n    });\n\n    settings.customBypassRules.forEach(value => {\n        if (isDomain(value)) {\n            dnsObject[\"nameserver-policy\"][`+.${value}`] = `${settings.localDNS}#DIRECT`;\n        }\n    });\n\n    settings.customBypassSanctionRules.forEach(value => {\n        if (isDomain(value)) {\n            dnsObject[\"nameserver-policy\"][`+.${value}`] = `${settings.antiSanctionDNS}#DIRECT`;\n        }\n    });\n\n    for (const { rule, ruleProvider, type, dns } of routingRules) {\n        if (!rule || !ruleProvider?.geosite) continue;\n        const { geosite } = ruleProvider;\n\n        if (type === 'DIRECT') {\n            dnsObject[\"nameserver-policy\"][`rule-set:${geosite}`] = dns;\n        } else {\n            if (!dnsObject[\"hosts\"]) {\n                dnsObject[\"hosts\"] = {};\n            }\n\n            dnsObject[\"hosts\"][`rule-set:${geosite}`] = \"rcode://refused\";\n        }\n    }\n\n    const isFakeDNS = (settings.VLTRFakeDNS && !isWarp) || (settings.warpFakeDNS && isWarp);\n\n    if (isFakeDNS) Object.assign(dnsObject, {\n        \"enhanced-mode\": \"fake-ip\",\n        \"fake-ip-range\": \"198.18.0.1/16\",\n        \"fake-ip-filter\": [\"*\", \"+.lan\", \"+.local\"]\n    });\n\n    return dnsObject;\n}\n\nfunction buildRoutingRules(isWarp) {\n    const routingRules = getRuleProviders();\n\n    settings.customBlockRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n        routingRules.push({\n            rule: true,\n            type: 'REJECT',\n            domain: isDomainValue ? value : null,\n            ip: isDomainValue ? null : value\n        });\n    });\n\n    const bypassRules = [\n        ...settings.customBypassRules,\n        ...settings.customBypassSanctionRules\n    ];\n\n    bypassRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n        routingRules.push({\n            rule: true,\n            type: 'DIRECT',\n            domain: isDomainValue ? value : null,\n            ip: isDomainValue ? null : value\n        });\n    });\n\n    const ruleProviders = {};\n\n    function addRuleProvider(ruleProvider) {\n        const { geosite, geoip, geositeURL, geoipURL, format } = ruleProvider;\n        const fileExtension = format === 'text' ? 'txt' : format;\n\n        const defineProvider = (type, behavior, url) => {\n            if (!type) return;\n            ruleProviders[type] = {\n                type: \"http\",\n                format,\n                behavior,\n                url,\n                path: `./ruleset/${type}.${fileExtension}`,\n                interval: 86400\n            };\n        };\n\n        defineProvider(geosite, 'domain', geositeURL);\n        defineProvider(geoip, 'ipcidr', geoipURL);\n    }\n\n    const groupedRules = new Map();\n\n    routingRules.forEach(routingRule => {\n        if (!routingRule.rule) return;\n        const { type, domain, ip, ruleProvider } = routingRule;\n        const { geosite, geoip } = ruleProvider || {};\n\n        if (!groupedRules.has(type)) groupedRules.set(type, {\n            domain: [],\n            ip: [],\n            geosite: [],\n            geoip: []\n        });\n\n        if (domain) groupedRules.get(type).domain.push(domain);\n        if (ip) groupedRules.get(type).ip.push(ip);\n        if (geosite) groupedRules.get(type).geosite.push(geosite);\n        if (geoip) groupedRules.get(type).geoip.push(geoip);\n        if (geosite || geoip) addRuleProvider(ruleProvider);\n    });\n\n    let rules = [`GEOIP,lan,DIRECT,no-resolve`];\n\n    if (!isWarp) {\n        rules.push(\"NETWORK,udp,REJECT\");\n    } else if (settings.blockUDP443) {\n        rules.push(\"AND,((NETWORK,udp),(DST-PORT,443)),REJECT\");\n    }\n\n    function addRoutingRule(geosites, geoips, domains, ips, type) {\n        if (domains) domains.forEach(domain => rules.push(`DOMAIN-SUFFIX,${domain},${type}`));\n        if (geosites) geosites.forEach(geosite => rules.push(`RULE-SET,${geosite},${type}`));\n\n        if (ips) ips.forEach(value => {\n            const ipType = isIPv4(value) ? 'IP-CIDR' : 'IP-CIDR6';\n            const ip = isIPv6(value) ? value.replace(/\\[|\\]/g, '') : value;\n            const cidr = value.includes('/') ? '' : isIPv4(value) ? '/32' : '/128';\n            rules.push(`${ipType},${ip}${cidr},${type}`);\n        });\n\n        if (geoips) geoips.forEach(geoip => rules.push(`RULE-SET,${geoip},${type}`));\n    }\n\n    for (const [type, rule] of groupedRules) {\n        const { domain, ip, geosite, geoip } = rule;\n\n        if (domain.length) addRoutingRule(null, null, domain, null, type);\n        if (geosite.length) addRoutingRule(geosite, null, null, null, type);\n        if (ip.length) addRoutingRule(null, null, null, ip, type);\n        if (geoip.length) addRoutingRule(null, geoip, null, null, type);\n    }\n\n    rules.push(\"MATCH,✅ Selector\");\n\n    return { rules, ruleProviders };\n}\n\nfunction buildVLOutbound(remark, address, port, host, sni, allowInsecure) {\n    const tls = isHttps(port);\n    const addr = isIPv6(address) ? address.replace(/\\[|\\]/g, '') : address;\n    const ipVersion = settings.VLTRenableIPv6 ? \"dual\" : \"ipv4\";\n    const fingerprint = settings.fingerprint === \"randomized\" ? \"random\" : settings.fingerprint;\n\n    const outbound = {\n        \"name\": remark,\n        \"type\": atob('dmxlc3M='),\n        \"server\": addr,\n        \"port\": port,\n        \"uuid\": globalConfig.userID,\n        \"udp\": false,\n        \"packet-encoding\": \"\",\n        \"ip-version\": ipVersion,\n        \"tls\": tls,\n        \"network\": \"ws\",\n        \"tfo\": true,\n        \"ws-opts\": {\n            \"path\": generateWsPath(\"vl\"),\n            \"headers\": { \"Host\": host },\n            \"max-early-data\": 2560,\n            \"early-data-header-name\": \"Sec-WebSocket-Protocol\"\n        }\n    };\n\n    if (tls) {\n        Object.assign(outbound, {\n            \"servername\": sni,\n            \"alpn\": [\"http/1.1\"],\n            \"client-fingerprint\": fingerprint,\n            \"skip-cert-verify\": allowInsecure\n        });\n    }\n\n    return outbound;\n}\n\nfunction buildTROutbound(remark, address, port, host, sni, allowInsecure) {\n    const addr = isIPv6(address) ? address.replace(/\\[|\\]/g, '') : address;\n    const ipVersion = settings.VLTRenableIPv6 ? \"dual\" : \"ipv4\";\n    const fingerprint = settings.fingerprint === \"randomized\" ? \"random\" : settings.fingerprint;\n\n    return {\n        \"name\": remark,\n        \"type\": atob('dHJvamFu'),\n        \"server\": addr,\n        \"port\": port,\n        \"password\": globalConfig.TrPass,\n        \"udp\": false,\n        \"ip-version\": ipVersion,\n        \"tls\": true,\n        \"network\": \"ws\",\n        \"tfo\": true,\n        \"ws-opts\": {\n            \"path\": generateWsPath(\"tr\"),\n            \"headers\": { \"Host\": host },\n            \"max-early-data\": 2560,\n            \"early-data-header-name\": \"Sec-WebSocket-Protocol\"\n        },\n        \"sni\": sni,\n        \"alpn\": [\"http/1.1\"],\n        \"client-fingerprint\": fingerprint,\n        \"skip-cert-verify\": allowInsecure\n    };\n}\n\nfunction buildWarpOutbound(warpConfigs, remark, endpoint, chain, isPro) {\n    const { host, port } = parseHostPort(endpoint);\n    const ipVersion = settings.warpEnableIPv6 ? \"dual\" : \"ipv4\";\n\n    const {\n        warpIPv6,\n        reserved,\n        publicKey,\n        privateKey\n    } = extractWireguardParams(warpConfigs, chain);\n\n    let outbound = {\n        \"name\": remark,\n        \"type\": \"wireguard\",\n        \"ip\": \"172.16.0.2/32\",\n        \"ipv6\": warpIPv6,\n        \"ip-version\": ipVersion,\n        \"private-key\": privateKey,\n        \"server\": chain ? \"162.159.192.1\" : host,\n        \"port\": chain ? 2408 : port,\n        \"public-key\": publicKey,\n        \"allowed-ips\": [\"0.0.0.0/0\", \"::/0\"],\n        \"reserved\": reserved,\n        \"udp\": true,\n        \"mtu\": 1280\n    };\n\n    if (chain) {\n        outbound[\"dialer-proxy\"] = chain;\n    }\n\n    if (isPro) outbound[\"amnezia-wg-option\"] = {\n        \"jc\": String(settings.amneziaNoiseCount),\n        \"jmin\": String(settings.amneziaNoiseSizeMin),\n        \"jmax\": String(settings.amneziaNoiseSizeMax)\n    }\n\n    return outbound;\n}\n\nfunction buildChainOutbound() {\n    const { outProxyParams } = settings;\n    const { protocol, server, port } = outProxyParams;\n    const outbound = {\n        \"name\": \"\",\n        \"type\": protocol,\n        \"server\": server,\n        \"port\": port,\n        \"dialer-proxy\": \"\"\n    };\n\n    if ([atob('c29ja3M='), \"http\"].includes(protocol)) {\n        const { user, pass } = outProxyParams;\n        outbound[\"username\"] = user;\n        outbound[\"password\"] = pass;\n\n        if (protocol === atob('c29ja3M=')) {\n            outbound[\"type\"] = atob('c29ja3M1');\n        }\n\n        return outbound;\n    }\n\n    if (protocol === atob('c2hhZG93c29ja3M=')) {\n        const { password, method } = outProxyParams;\n        outbound[\"cipher\"] = method;\n        outbound[\"password\"] = password;\n        outbound[\"type\"] = atob('c3M=');\n\n        return outbound;\n    }\n\n    const {\n        security, type, sni, fp, alpn, pbk,\n        sid, headerType, host, path, serviceName\n    } = outProxyParams;\n\n    if (protocol === atob('dmxlc3M=')) {\n        const { uuid, flow } = outProxyParams;\n        outbound[\"uuid\"] = uuid;\n        outbound[\"flow\"] = flow;\n    }\n\n    if (protocol === atob('dHJvamFu')) {\n        const { password } = outProxyParams;\n        outbound[\"password\"] = password;\n    }\n\n    if (security === 'tls') {\n        const tlsAlpns = alpn ? alpn?.split(',') : [];\n        Object.assign(outbound, {\n            \"tls\": true,\n            \"servername\": sni,\n            \"alpn\": tlsAlpns,\n            \"client-fingerprint\": fp\n        });\n    }\n\n    if (security === 'reality') Object.assign(outbound, {\n        \"tls\": true,\n        \"servername\": sni,\n        \"client-fingerprint\": fp,\n        \"reality-opts\": {\n            \"public-key\": pbk,\n            \"short-id\": sid\n        }\n    });\n\n    if (headerType === 'http') {\n        outbound[\"network\"] = \"http\";\n        const httpPaths = path?.split(',');\n        outbound[\"http-opts\"] = {\n            \"method\": \"GET\",\n            \"path\": httpPaths,\n            \"headers\": {\n                \"Connection\": [\"keep-alive\"],\n                \"Content-Type\": [\"application/octet-stream\"]\n            }\n        };\n    }\n\n    if (type === 'ws' || type === 'httpupgrade') {\n        const wsPath = path?.split('?ed=')[0];\n        outbound[\"network\"] = \"ws\";\n        outbound[\"ws-opts\"] = {\n            \"path\": wsPath,\n            \"headers\": {\n                \"Host\": host\n            }\n        };\n\n        if (type === 'httpupgrade') {\n            outbound[\"ws-opts\"][`${atob('djJyYXk=')}-http-upgrade`] = true;\n            outbound[\"ws-opts\"][`${atob('djJyYXk=')}-http-upgrade-fast-open`] = true;\n        } else {\n            const earlyData = +path?.split('?ed=')[1];\n            outbound[\"ws-opts\"][\"max-early-data\"] = earlyData;\n            outbound[\"ws-opts\"][\"early-data-header-name\"] = \"Sec-WebSocket-Protocol\";\n        }\n    }\n\n    if (type === 'grpc') {\n        outbound[\"network\"] = type;\n        outbound[\"grpc-opts\"] = {\n            \"grpc-service-name\": serviceName\n        };\n    }\n\n    return outbound;\n}\n\nasync function buildConfig(outbounds, selectorTags, proxyTags, chainTags, isChain, isWarp, isPro) {\n    const { rules, ruleProviders } = buildRoutingRules(isWarp);\n    const config = {\n        \"mixed-port\": 7890,\n        \"ipv6\": true,\n        \"allow-lan\": true,\n        \"mode\": \"rule\",\n        \"log-level\": \"warning\",\n        \"disable-keep-alive\": false,\n        \"keep-alive-idle\": 10,\n        \"keep-alive-interval\": 15,\n        ...(!isWarp && { \"tcp-concurrent\": true }),\n        \"unified-delay\": false,\n        \"geo-auto-update\": true,\n        \"geo-update-interval\": 168,\n        \"external-controller\": \"127.0.0.1:9090\",\n        \"external-ui-url\": \"https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip\",\n        \"external-ui\": \"ui\",\n        \"external-controller-cors\": {\n            \"allow-origins\": [\"*\"],\n            \"allow-private-network\": true\n        },\n        \"profile\": {\n            \"store-selected\": true,\n            \"store-fake-ip\": true\n        },\n        \"dns\": await buildDNS(isChain, isWarp, isPro),\n        \"tun\": {\n            \"enable\": true,\n            \"stack\": \"mixed\",\n            \"auto-route\": true,\n            \"strict-route\": true,\n            \"auto-detect-interface\": true,\n            \"dns-hijack\": [\n                \"any:53\",\n                \"tcp://any:53\"\n            ],\n            \"mtu\": 9000\n        },\n        \"sniffer\": {\n            \"enable\": true,\n            \"force-dns-mapping\": true,\n            \"parse-pure-ip\": true,\n            \"override-destination\": true,\n            \"sniff\": {\n                \"HTTP\": {\n                    \"ports\": [80, 8080, 8880, 2052, 2082, 2086, 2095]\n                },\n                \"TLS\": {\n                    \"ports\": [443, 8443, 2053, 2083, 2087, 2096]\n                }\n            }\n        },\n        \"proxies\": outbounds,\n        \"proxy-groups\": [\n            {\n                \"name\": \"✅ Selector\",\n                \"type\": \"select\",\n                \"proxies\": selectorTags\n            }\n        ],\n        \"rule-providers\": ruleProviders,\n        \"rules\": rules,\n        \"ntp\": {\n            \"enable\": true,\n            \"server\": \"time.cloudflare.com\",\n            \"port\": 123,\n            \"interval\": 30\n        }\n    };\n\n    const addUrlTest = (name, proxies) => config['proxy-groups'].push({\n        \"name\": name,\n        \"type\": \"url-test\",\n        \"url\": \"https://www.gstatic.com/generate_204\",\n        \"interval\": isWarp ? settings.bestWarpInterval : settings.bestVLTRInterval,\n        \"tolerance\": 50,\n        \"proxies\": proxies\n    });\n\n    addUrlTest(isWarp ? `💦 Warp ${isPro ? 'Pro ' : ''}- Best Ping 🚀` : '💦 Best Ping 🚀', proxyTags);\n\n    if (isWarp) {\n        addUrlTest(`💦 WoW ${isPro ? 'Pro ' : ''}- Best Ping 🚀`, chainTags);\n    }\n\n    if (isChain) {\n        addUrlTest('💦 🔗 Best Ping 🚀', chainTags);\n    }\n\n    return config;\n}\n\nexport async function getClNormalConfig(env) {\n    let chainProxy;\n\n    if (settings.outProxy) {\n        chainProxy = await parseChainProxy(env, buildChainOutbound);\n    }\n\n    const Addresses = await getConfigAddresses(false);\n    const proxyTags = [];\n    const chainTags = [];\n    const outbounds = [];\n    const protocols = [\n        ...(settings.VLConfigs ? [atob('VkxFU1M=')] : []),\n        ...(settings.TRConfigs ? [atob('VHJvamFu')] : [])\n    ];\n\n    const selectorTags = [\n        '💦 Best Ping 🚀',\n        ...(chainProxy ? ['💦 🔗 Best Ping 🚀'] : [])\n    ];\n\n    protocols.forEach(protocol => {\n        let protocolIndex = 1;\n        settings.ports.forEach(port => {\n            Addresses.forEach(addr => {\n                let outbound;\n                const isCustomAddr = settings.customCdnAddrs.includes(addr);\n                const configType = isCustomAddr ? 'C' : '';\n                const sni = isCustomAddr ? settings.customCdnSni : randomUpperCase(httpConfig.hostName);\n                const host = isCustomAddr ? settings.customCdnHost : httpConfig.hostName;\n                const tag = generateRemark(protocolIndex, port, addr, protocol, configType).replace(' : ', ' - ');\n\n                if (protocol === atob('VkxFU1M=')) {\n                    outbound = buildVLOutbound(tag, addr, port, host, sni, isCustomAddr);\n                }\n\n                if (protocol === atob('VHJvamFu') && isHttps(port)) {\n                    outbound = buildTROutbound(tag, addr, port, host, sni, isCustomAddr);\n                }\n                \n                if (outbound) {\n                    proxyTags.push(tag);\n                    selectorTags.push(tag);\n                    outbounds.push(outbound);\n                    \n                    if (chainProxy) {\n                        const chainTag = generateRemark(protocolIndex, port, addr, protocol, configType, true);\n                        let chain = structuredClone(chainProxy);\n                        chain['name'] = chainTag;\n                        chain['dialer-proxy'] = tag;\n                        outbounds.push(chain);\n                        \n                        chainTags.push(chainTag);\n                        selectorTags.push(chainTag);\n                    }\n                    \n                    protocolIndex++;\n                }\n            });\n        });\n    });\n\n    const config = await buildConfig(outbounds, selectorTags, proxyTags, chainTags, chainProxy, false, false);\n\n    return new Response(JSON.stringify(config, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nexport async function getClWarpConfig(request, env, isPro) {\n    const { warpConfigs } = await getDataset(request, env);\n    const proxyTags = [], chainTags = [];\n    const outbounds = [];\n    const selectorTags = [\n        `💦 Warp ${isPro ? 'Pro ' : ''}- Best Ping 🚀`,\n        `💦 WoW ${isPro ? 'Pro ' : ''}- Best Ping 🚀`\n    ];\n\n    settings.warpEndpoints.forEach((endpoint, index) => {\n        const warpTag = `💦 ${index + 1} - Warp ${isPro ? 'Pro ' : ''}🇮🇷`;\n        proxyTags.push(warpTag);\n\n        const wowTag = `💦 ${index + 1} - WoW ${isPro ? 'Pro ' : ''}🌍`;\n        chainTags.push(wowTag);\n\n        selectorTags.push(warpTag, wowTag);\n        const warpOutbound = buildWarpOutbound(warpConfigs, warpTag, endpoint, '', isPro);\n        const wowOutbound = buildWarpOutbound(warpConfigs, wowTag, endpoint, warpTag);\n        outbounds.push(warpOutbound, wowOutbound);\n    });\n\n    const config = await buildConfig(outbounds, selectorTags, proxyTags, chainTags, false, true, isPro);\n\n    return new Response(JSON.stringify(config, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nfunction getRuleProviders() {\n    const finalLocalDNS = settings.localDNS === 'localhost'\n        ? 'system'\n        : `${settings.localDNS}#DIRECT`;\n\n    return [\n        {\n            rule: true,\n            type: 'REJECT',\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"malware\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/malware.txt\",\n                geoip: \"malware-cidr\",\n                geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/malware-ip.txt\",\n            }\n        },\n        {\n            rule: true,\n            type: 'REJECT',\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"phishing\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/phishing.txt\",\n                geoip: \"phishing-cidr\",\n                geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/phishing-ip.txt\",\n            }\n        },\n        {\n            rule: true,\n            type: 'REJECT',\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"cryptominers\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/cryptominers.txt\"\n            }\n        },\n        {\n            rule: settings.blockAds,\n            type: 'REJECT',\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"category-ads-all\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/category-ads-all.txt\"\n            }\n        },\n        {\n            rule: settings.blockPorn,\n            type: 'REJECT',\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"nsfw\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/nsfw.txt\",\n            }\n        },\n        {\n            rule: settings.bypassIran,\n            type: 'DIRECT',\n            dns: finalLocalDNS,\n            ruleProvider: {\n                format: \"text\",\n                geosite: \"ir\",\n                geoip: \"ir-cidr\",\n                geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/ir.txt\",\n                geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-clash-rules/release/ircidr.txt\"\n            }\n        },\n        {\n            rule: settings.bypassChina,\n            type: 'DIRECT',\n            dns: finalLocalDNS,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"cn\",\n                geoip: \"cn-cidr\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/cn.yaml\",\n                geoipURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geoip/cn.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassRussia,\n            type: 'DIRECT',\n            dns: finalLocalDNS,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"ru\",\n                geoip: \"ru-cidr\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/category-ru.yaml\",\n                geoipURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geoip/ru.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassOpenAi,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"openai\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/openai.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassMicrosoft,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"microsoft\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/microsoft.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassOracle,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"oracle\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/oracle.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassDocker,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"docker\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/docker.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassAdobe,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"adobe\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/adobe.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassEpicGames,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"epicgames\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/epicgames.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassIntel,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"intel\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/intel.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassAmd,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"amd\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/amd.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassNvidia,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"nvidia\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/nvidia.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassAsus,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"asus\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/asus.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassHp,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"hp\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/hp.yaml\"\n            }\n        },\n        {\n            rule: settings.bypassLenovo,\n            type: 'DIRECT',\n            dns: `${settings.antiSanctionDNS}#DIRECT`,\n            ruleProvider: {\n                format: \"yaml\",\n                geosite: \"lenovo\",\n                geositeURL: \"https://raw.githubusercontent.com/MetaCubeX/meta-rules-dat/meta/geo/geosite/lenovo.yaml\"\n            }\n        },\n    ];\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/configs/sing-box.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":20,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":20,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":358,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":358,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":394,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":394,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":480,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":480,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":485,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":485,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":492,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":492,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":500,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":500,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":506,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":506,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":684,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":684,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":685,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":685,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":708,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":708,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":718,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":718,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":734,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":734,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":768,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":768,"endColumn":24}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDataset } from '#kv';\nimport { globalConfig, httpConfig } from '#common/init';\nimport { settings } from '#common/handlers'\nimport {\n    getConfigAddresses,\n    extractWireguardParams,\n    generateRemark,\n    randomUpperCase,\n    isIPv6,\n    isDomain,\n    isHttps,\n    base64ToDecimal,\n    getDomain,\n    generateWsPath,\n    parseHostPort,\n    parseChainProxy\n} from '#configs/utils';\n\nasync function buildDNS(isWarp, isChain) {\n    const url = new URL(settings.remoteDNS);\n    const dnsProtocol = url.protocol.replace(':', '');\n\n    const servers = [\n        {\n            type: isWarp ? \"udp\" : dnsProtocol,\n            server: isWarp ? \"1.1.1.1\" : settings.dohHost.host,\n            detour: isWarp ? \"💦 Warp - Best Ping 🚀\" : isChain ? \"💦 Best Ping 🚀\" : \"✅ Selector\",\n            tag: \"dns-remote\"\n        },\n    ];\n\n    function addDnsServer(type, server, server_port, detour, tag, domain_resolver) {\n        servers.push({\n            type,\n            ...(server && { server }),\n            ...(server_port && { server_port }),\n            ...(detour && { detour }),\n            ...(domain_resolver && {\n                domain_resolver: {\n                    server: domain_resolver,\n                    strategy: \"ipv4_only\"\n                }\n            }),\n            tag\n        });\n    }\n\n    if (settings.localDNS === 'localhost') {\n        addDnsServer(\"local\", null, null, null, \"dns-direct\");\n    } else {\n        addDnsServer(\"udp\", settings.localDNS, 53, null, \"dns-direct\");\n    }\n\n    const rules = [\n        {\n            domain: [\"raw.githubusercontent.com\"],\n            server: \"dns-direct\"\n        },\n        {\n            clash_mode: \"Direct\",\n            server: \"dns-direct\"\n        },\n        {\n            clash_mode: \"Global\",\n            server: \"dns-remote\"\n        }\n    ];\n\n    if (isChain) {\n        const { server } = settings.outProxyParams;\n\n        if (isDomain(server)) {\n            rules.unshift({\n                domain: server,\n                server: \"dns-remote\"\n            });\n        }\n    }\n\n    if (settings.dohHost.isDomain && !isWarp) {\n        const { ipv4, ipv6, host } = settings.dohHost;\n\n        servers.push({\n            type: \"hosts\",\n            tag: \"hosts\",\n            predefined: {\n                [host]: [\n                    ...ipv4,\n                    ...(settings.VLTRenableIPv6 ? ipv6 : [])\n                ]\n            }\n        });\n\n        rules.unshift({\n            ip_accept_any: true,\n            server: \"hosts\"\n        });\n    }\n\n    function addDnsRule(geosite, geoip, domain, dns) {\n        let type, mode;\n        const ruleSets = [];\n\n        if (geoip) {\n            mode = 'and';\n            type = 'logical';\n            ruleSets.push({ rule_set: geosite }, { rule_set: geoip });\n        }\n\n        const action = dns === 'reject' ? 'reject' : 'route';\n        const server = dns === 'reject' ? null : dns;\n\n        rules.push({\n            ...(type && { type }),\n            ...(mode && { mode }),\n            ...(ruleSets.length && { rules: ruleSets }),\n            ...(geosite && !geoip && { rule_set: geosite }),\n            ...(domain && { domain_suffix: domain }),\n            action,\n            ...(server && { server })\n        });\n    }\n\n    const routingRules = getRuleSets();\n\n    settings.customBlockRules.forEach(value => {\n        isDomain(value) && routingRules.unshift({\n            rule: true,\n            domain: value,\n            type: 'reject'\n        });\n    });\n\n    settings.customBypassRules.forEach(value => {\n        isDomain(value) && routingRules.push({\n            rule: true,\n            domain: value,\n            type: 'direct',\n            dns: \"dns-direct\"\n        });\n    });\n\n    settings.customBypassSanctionRules.forEach(value => {\n        isDomain(value) && routingRules.push({\n            rule: true,\n            domain: value,\n            type: 'direct',\n            dns: \"dns-anti-sanction\"\n        });\n    });\n\n    const groupedRules = new Map();\n\n    for (const { rule, geosite, geoip, domain, type, dns } of routingRules) {\n        if (!rule) continue;\n\n        if (geosite && geoip && type === 'direct') {\n            addDnsRule(geosite, geoip, null, dns);\n        } else {\n            const dnsType = dns || type;\n            if (!groupedRules.has(dnsType)) groupedRules.set(dnsType, { geosite: [], domain: [] });\n            if (geosite) groupedRules.get(dnsType).geosite.push(geosite);\n            if (domain) groupedRules.get(dnsType).domain.push(domain);\n        }\n    }\n\n    for (const [dnsType, rule] of groupedRules) {\n        const { geosite, domain } = rule;\n        if (domain.length) addDnsRule(null, null, domain, dnsType);\n        if (geosite.length) addDnsRule(geosite, null, null, dnsType);\n    }\n\n    const isSanctionRule = groupedRules.has(\"dns-anti-sanction\");\n\n    if (isSanctionRule) {\n        const dnsHost = getDomain(settings.antiSanctionDNS);\n\n        if (dnsHost.isHostDomain) {\n            addDnsServer(\"https\", dnsHost.host, 443, null, \"dns-anti-sanction\", \"dns-direct\");\n        } else {\n            addDnsServer(\"udp\", settings.antiSanctionDNS, 53, null, \"dns-anti-sanction\", null);\n        }\n    }\n\n    const isFakeDNS = (settings.VLTRFakeDNS && !isWarp) || (settings.warpFakeDNS && isWarp);\n\n    if (isFakeDNS) {\n        const fakeip = {\n            type: \"fakeip\",\n            tag: \"dns-fake\",\n            inet4_range: \"198.18.0.0/15\"\n        };\n\n        const isIPv6 = (settings.VLTRenableIPv6 && !isWarp) || (settings.warpEnableIPv6 && isWarp);\n\n        if (isIPv6) {\n            fakeip.inet6_range = \"fc00::/18\";\n        }\n\n        servers.push(fakeip);\n        rules.push({\n            disable_cache: true,\n            inbound: \"tun-in\",\n            query_type: [\n                \"A\",\n                \"AAAA\"\n            ],\n            server: \"dns-fake\"\n        });\n    }\n\n    return {\n        servers,\n        rules,\n        strategy: \"ipv4_only\",\n        independent_cache: true\n    }\n}\n\nfunction buildRoutingRules(isWarp) {\n    const rules = [\n        {\n            ip_cidr: \"172.18.0.2\",\n            action: \"hijack-dns\"\n        },\n        {\n            clash_mode: \"Direct\",\n            outbound: \"direct\"\n        },\n        {\n            clash_mode: \"Global\",\n            outbound: \"✅ Selector\"\n        },\n        {\n            action: \"sniff\"\n        },\n        {\n            protocol: \"dns\",\n            action: \"hijack-dns\"\n        },\n        {\n            ip_is_private: true,\n            outbound: \"direct\"\n        }\n    ];\n\n    function addRoutingRule(domain, ip, geosite, geoip, network, protocol, port, type) {\n        const action = type === 'reject' ? 'reject' : 'route';\n        const outbound = type === 'direct' ? 'direct' : null;\n\n        rules.push({\n            ...(geosite && { rule_set: geosite }),\n            ...(geoip && { rule_set: geoip }),\n            ...(domain && { domain_suffix: domain }),\n            ...(ip && { ip_cidr: ip }),\n            ...(network && { network }),\n            ...(protocol && { protocol }),\n            ...(port && { port }),\n            action,\n            ...(outbound && { outbound })\n        });\n    }\n\n    if (!isWarp) {\n        addRoutingRule(null, null, null, null, \"udp\", null, null, 'reject');\n    } else if (settings.blockUDP443) {\n        addRoutingRule(null, null, null, null, \"udp\", \"quic\", 443, 'reject');\n    }\n\n    const routingRules = getRuleSets();\n\n    settings.customBlockRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n        routingRules.push({\n            rule: true,\n            type: 'reject',\n            domain: isDomainValue ? value : null,\n            ip: isDomainValue ? null : isIPv6(value) ? value.replace(/\\[|\\]/g, '') : value\n        });\n    });\n\n    const bypassRules = [\n        ...settings.customBypassRules,\n        ...settings.customBypassSanctionRules\n    ];\n\n    bypassRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n\n        routingRules.push({\n            rule: true,\n            type: 'direct',\n            domain: isDomainValue ? value : null,\n            ip: isDomainValue ? null : isIPv6(value) ? value.replace(/\\[|\\]/g, '') : value\n        });\n    });\n\n    const ruleSets = [];\n\n    function addRuleSet(geoRule) {\n        const { geosite, geositeURL, geoip, geoipURL } = geoRule;\n\n        if (geosite) ruleSets.push({\n            type: \"remote\",\n            tag: geosite,\n            format: \"binary\",\n            url: geositeURL,\n            download_detour: \"direct\"\n        });\n\n        if (geoip) ruleSets.push({\n            type: \"remote\",\n            tag: geoip,\n            format: \"binary\",\n            url: geoipURL,\n            download_detour: \"direct\"\n        });\n    }\n\n    const groupedRules = new Map();\n\n    routingRules.forEach(routingRule => {\n        const { rule, type, domain, ip, geosite, geoip } = routingRule;\n        if (!rule) return;\n        if (!groupedRules.has(type)) groupedRules.set(type, { domain: [], ip: [], geosite: [], geoip: [] });\n        if (domain) groupedRules.get(type).domain.push(domain);\n        if (ip) groupedRules.get(type).ip.push(ip);\n        if (geosite) groupedRules.get(type).geosite.push(geosite);\n        if (geoip) groupedRules.get(type).geoip.push(geoip);\n        if (geosite || geoip) addRuleSet(routingRule);\n    });\n\n    for (const [type, rule] of groupedRules) {\n        const { domain, ip, geosite, geoip } = rule;\n\n        if (domain.length) addRoutingRule(domain, null, null, null, null, null, null, type);\n        if (geosite.length) addRoutingRule(null, null, geosite, null, null, null, null, type);\n        if (ip.length) addRoutingRule(null, ip, null, null, null, null, null, type);\n        if (geoip.length) addRoutingRule(null, null, null, geoip, null, null, null, type);\n    }\n\n    return {\n        rules,\n        rule_set: ruleSets,\n        auto_detect_interface: true,\n        default_domain_resolver: {\n            server: \"dns-direct\",\n            strategy: settings.VLTRenableIPv6 ? \"prefer_ipv4\" : \"ipv4_only\",\n            rewrite_ttl: 60\n        },\n        final: \"✅ Selector\"\n    }\n}\n\nfunction buildVLOutbound(remark, address, port, host, sni, allowInsecure, isFragment) {\n    const outbound = {\n        tag: remark,\n        type: atob('dmxlc3M='),\n        server: address,\n        server_port: port,\n        uuid: globalConfig.userID,\n        network: \"tcp\",\n        tcp_fast_open: true,\n        packet_encoding: \"\",\n        transport: {\n            early_data_header_name: \"Sec-WebSocket-Protocol\",\n            max_early_data: 2560,\n            headers: {\n                Host: host\n            },\n            path: generateWsPath(\"vl\"),\n            type: \"ws\"\n        }\n    };\n\n    if (isHttps(port)) outbound.tls = {\n        alpn: \"http/1.1\",\n        enabled: true,\n        insecure: allowInsecure,\n        server_name: sni,\n        record_fragment: isFragment,\n        utls: {\n            enabled: true,\n            fingerprint: settings.fingerprint\n        }\n    };\n\n    return outbound;\n}\n\nfunction buildTROutbound(remark, address, port, host, sni, allowInsecure, isFragment) {\n    const outbound = {\n        tag: remark,\n        type: atob('dHJvamFu'),\n        password: globalConfig.TrPass,\n        server: address,\n        server_port: port,\n        network: \"tcp\",\n        tcp_fast_open: true,\n        transport: {\n            early_data_header_name: \"Sec-WebSocket-Protocol\",\n            max_early_data: 2560,\n            headers: {\n                Host: host\n            },\n            path: generateWsPath(\"tr\"),\n            type: \"ws\"\n        }\n    }\n\n    if (isHttps(port)) outbound.tls = {\n        alpn: \"http/1.1\",\n        enabled: true,\n        insecure: allowInsecure,\n        server_name: sni,\n        record_fragment: isFragment,\n        utls: {\n            enabled: true,\n            fingerprint: settings.fingerprint\n        }\n    };\n\n    return outbound;\n}\n\nfunction buildWarpOutbound(warpConfigs, remark, endpoint, chain) {\n    const { host, port } = parseHostPort(endpoint);\n    const server = chain ? \"162.159.192.1\" : host;\n    const finalPort = chain ? 2408 : port;\n\n    const {\n        warpIPv6,\n        reserved,\n        publicKey,\n        privateKey\n    } = extractWireguardParams(warpConfigs, chain);\n\n    const outbound = {\n        tag: remark,\n        type: \"wireguard\",\n        address: [\n            \"172.16.0.2/32\",\n            warpIPv6\n        ],\n        mtu: 1280,\n        peers: [\n            {\n                address: server,\n                port: finalPort,\n                public_key: publicKey,\n                reserved: base64ToDecimal(reserved),\n                allowed_ips: [\n                    \"0.0.0.0/0\",\n                    \"::/0\"\n                ],\n                persistent_keepalive_interval: 5\n            }\n        ],\n        private_key: privateKey\n    };\n\n    if (chain) {\n        outbound.detour = chain;\n    }\n\n    return outbound;\n}\n\nfunction buildChainOutbound() {\n    const { outProxyParams } = settings;\n    const { protocol, server, port } = outProxyParams;\n    const outbound = {\n        type: protocol,\n        tag: \"\",\n        server,\n        server_port: port,\n        detour: \"\"\n    };\n\n    if ([atob('c29ja3M='), \"http\"].includes(protocol)) {\n        const { user, pass } = outProxyParams;\n        outbound.username = user;\n        outbound.password = pass;\n\n        if (protocol === atob('c29ja3M=')) {\n            outbound.version = \"5\";\n        }\n\n        return outbound;\n    }\n\n    if (protocol === atob('c2hhZG93c29ja3M=')) {\n        const { password, method } = outProxyParams;\n        outbound.method = method;\n        outbound.password = password;\n\n        return outbound;\n    }\n\n    if (protocol === atob('dmxlc3M=')) {\n        const { uuid, flow } = outProxyParams;\n        outbound.uuid = uuid;\n        outbound.flow = flow;\n    }\n\n    if (protocol === atob('dHJvamFu')) {\n        const { password } = outProxyParams;\n        outbound.password = password;\n    }\n\n    const {\n        security, type, sni, fp, alpn, pbk, sid,\n        headerType, host, path, serviceName\n    } = outProxyParams;\n\n    if (security === 'tls' || security === 'reality') {\n        const tlsAlpns = alpn ? alpn?.split(',').filter(value => value !== 'h2') : [];\n        outbound.tls = {\n            enabled: true,\n            server_name: sni,\n            insecure: false,\n            alpn: tlsAlpns,\n            utls: {\n                enabled: true,\n                fingerprint: fp\n            }\n        };\n\n        if (security === 'reality') {\n            outbound.tls.reality = {\n                enabled: true,\n                public_key: pbk,\n                short_id: sid\n            };\n\n            delete outbound.tls.alpn;\n        }\n    }\n\n    if (headerType === 'http') {\n        const httpHosts = host?.split(',');\n        outbound.transport = {\n            type: \"http\",\n            host: httpHosts,\n            path: path,\n            method: \"GET\",\n            headers: {\n                \"Connection\": [\"keep-alive\"],\n                \"Content-Type\": [\"application/octet-stream\"]\n            },\n        };\n    }\n\n    if (type === 'ws' || type === 'httpupgrade') {\n        const configPath = path?.split('?ed=')[0];\n        outbound.transport = {\n            type: type,\n            path: configPath,\n\n        };\n\n        if (type === 'ws') {\n            const earlyData = +path?.split('?ed=')[1] || 0;\n            Object.assign(outbound.transport, {\n                max_early_data: earlyData,\n                early_data_header_name: \"Sec-WebSocket-Protocol\",\n                headers: { Host: host }\n            });\n        } else {\n            outbound.transport.host = host;\n        }\n    }\n\n    if (type === 'grpc') outbound.transport = {\n        type: \"grpc\",\n        service_name: serviceName\n    };\n\n    return outbound;\n}\n\nasync function buildConfig(outbounds, endpoints, selectorTags, urlTestTags, secondUrlTestTags, isWarp, isIPv6, isChain) {\n    const config = {\n        log: {\n            level: \"warn\",\n            timestamp: true\n        },\n        dns: await buildDNS(isWarp, isChain),\n        inbounds: [\n            {\n                type: \"tun\",\n                tag: \"tun-in\",\n                address: [\n                    \"172.18.0.1/30\",\n                    ...(isIPv6 ? [\"fdfe:dcba:9876::1/126\"] : [])\n                ],\n                mtu: 9000,\n                auto_route: true,\n                strict_route: true,\n                endpoint_independent_nat: true,\n                stack: \"mixed\"\n            },\n            {\n                type: \"mixed\",\n                tag: \"mixed-in\",\n                listen: \"0.0.0.0\",\n                listen_port: 2080\n            }\n        ],\n        outbounds: [\n            ...outbounds,\n            {\n                type: \"selector\",\n                tag: \"✅ Selector\",\n                outbounds: selectorTags,\n                interrupt_exist_connections: false\n            },\n            {\n                type: \"direct\",\n                tag: \"direct\"\n            }\n        ],\n        route: buildRoutingRules(isWarp),\n        ntp: {\n            enabled: true,\n            server: \"time.cloudflare.com\",\n            server_port: 123,\n            domain_resolver: \"dns-direct\",\n            interval: \"30m\",\n            write_to_system: false\n        },\n        experimental: {\n            cache_file: {\n                enabled: true,\n                store_fakeip: true\n            },\n            clash_api: {\n                external_controller: \"127.0.0.1:9090\",\n                external_ui: \"ui\",\n                external_ui_download_url: \"https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip\",\n                external_ui_download_detour: \"direct\",\n                default_mode: \"Rule\"\n            }\n        }\n    };\n\n    if(endpoints.length) {\n        config.endpoints = endpoints;\n    }\n\n    const addUrlTest = (tag, outbounds) => config.outbounds.push({\n        type: \"urltest\",\n        tag,\n        outbounds,\n        url: \"https://www.gstatic.com/generate_204\",\n        interrupt_exist_connections: false,\n        interval: isWarp ? `${settings.bestWarpInterval}s` : `${settings.bestVLTRInterval}s`\n    });\n\n    addUrlTest(isWarp ? `💦 Warp - Best Ping 🚀` : '💦 Best Ping 🚀', urlTestTags);\n\n    if (isWarp) {\n        addUrlTest('💦 WoW - Best Ping 🚀', secondUrlTestTags);\n    }\n\n    if (isChain) {\n        addUrlTest('💦 🔗 Best Ping 🚀', secondUrlTestTags);\n    }\n\n    return config;\n}\n\nexport async function getSbCustomConfig(env, isFragment) {\n    let chainProxy;\n\n    if (settings.outProxy) {\n        chainProxy = await parseChainProxy(env, buildChainOutbound);\n    }\n\n    const proxyTags = [];\n    const chainTags = [];\n    const outbounds = [];\n    const protocols = [\n        ...(settings.VLConfigs ? [atob('VkxFU1M=')] : []),\n        ...(settings.TRConfigs ? [atob('VHJvamFu')] : [])\n    ];\n\n    const Addresses = await getConfigAddresses(isFragment);\n    const ports = isFragment\n        ? settings.ports.filter(port => isHttps(port))\n        : settings.ports;\n\n    const selectorTags = [\n        '💦 Best Ping 🚀',\n        ...(chainProxy ? ['💦 🔗 Best Ping 🚀'] : [])\n    ];\n\n    protocols.forEach(protocol => {\n        let protocolIndex = 1;\n        ports.forEach(port => {\n            Addresses.forEach(addr => {\n                const isCustomAddr = settings.customCdnAddrs.includes(addr);\n                const configType = isFragment ? 'F' : isCustomAddr ? 'C' : '';\n                const sni = isCustomAddr ? settings.customCdnSni : randomUpperCase(httpConfig.hostName);\n                const host = isCustomAddr ? settings.customCdnHost : httpConfig.hostName;\n                const tag = generateRemark(protocolIndex, port, addr, protocol, configType);\n\n                const outbound = protocol === atob('VkxFU1M=')\n                    ? buildVLOutbound(tag, addr, port, host, sni, isCustomAddr, isFragment)\n                    : buildTROutbound(tag, addr, port, host, sni, isCustomAddr, isFragment);\n                \n                outbounds.push(outbound);\n                proxyTags.push(tag);\n                selectorTags.push(tag);\n\n                if (chainProxy) {\n                    const chainTag = generateRemark(protocolIndex, port, addr, protocol, configType, true);\n                    const chain = structuredClone(chainProxy);\n                    chain.tag = chainTag;\n                    chain.detour = tag;\n                    outbounds.push(chain);\n                    \n                    chainTags.push(chainTag);\n                    selectorTags.push(chainTag);\n                }\n\n                protocolIndex++;\n            });\n        });\n    });\n\n    const config = await buildConfig(outbounds, [], selectorTags, proxyTags, chainTags, false, settings.VLTRenableIPv6, chainProxy);\n\n    return new Response(JSON.stringify(config, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nexport async function getSbWarpConfig(request, env) {\n    const { warpConfigs } = await getDataset(request, env);\n    const proxyTags = [], chainTags = [];\n    const outbounds = [];\n    const selectorTags = [\n        '💦 Warp - Best Ping 🚀',\n        '💦 WoW - Best Ping 🚀'\n    ];\n\n    settings.warpEndpoints.forEach((endpoint, index) => {\n        const warpTag = `💦 ${index + 1} - Warp 🇮🇷`;\n        proxyTags.push(warpTag);\n\n        const wowTag = `💦 ${index + 1} - WoW 🌍`;\n        chainTags.push(wowTag);\n\n        selectorTags.push(warpTag, wowTag);\n        const warpOutbound = buildWarpOutbound(warpConfigs, warpTag, endpoint, '');\n        const wowOutbound = buildWarpOutbound(warpConfigs, wowTag, endpoint, warpTag);\n        outbounds.push(warpOutbound, wowOutbound);\n    });\n\n    const config = await buildConfig([], outbounds, selectorTags, proxyTags, chainTags, true, settings.warpEnableIPv6);\n\n    return new Response(JSON.stringify(config, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nfunction getRuleSets() {\n    return [\n        {\n            rule: true,\n            type: 'reject',\n            geosite: \"geosite-malware\",\n            geoip: \"geoip-malware\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-malware.srs\",\n            geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geoip-malware.srs\"\n        },\n        {\n            rule: true,\n            type: 'reject',\n            geosite: \"geosite-phishing\",\n            geoip: \"geoip-phishing\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-phishing.srs\",\n            geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geoip-phishing.srs\"\n        },\n        {\n            rule: true,\n            type: 'reject',\n            geosite: \"geosite-cryptominers\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-cryptominers.srs\",\n        },\n        {\n            rule: settings.blockAds,\n            type: 'reject',\n            geosite: \"geosite-category-ads-all\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-category-ads-all.srs\",\n        },\n        {\n            rule: settings.blockPorn,\n            type: 'reject',\n            geosite: \"geosite-nsfw\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-nsfw.srs\",\n        },\n        {\n            rule: settings.bypassIran,\n            type: 'direct',\n            dns: \"dns-direct\",\n            geosite: \"geosite-ir\",\n            geoip: \"geoip-ir\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-ir.srs\",\n            geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geoip-ir.srs\"\n        },\n        {\n            rule: settings.bypassChina,\n            type: 'direct',\n            dns: \"dns-direct\",\n            geosite: \"geosite-cn\",\n            geoip: \"geoip-cn\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-cn.srs\",\n            geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geoip-cn.srs\"\n        },\n        {\n            rule: settings.bypassRussia,\n            type: 'direct',\n            dns: \"dns-direct\",\n            geosite: \"geosite-category-ru\",\n            geoip: \"geoip-ru\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-category-ru.srs\",\n            geoipURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geoip-ru.srs\"\n        },\n        {\n            rule: settings.bypassOpenAi,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-openai\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-openai.srs\"\n        },\n        {\n            rule: settings.bypassMicrosoft,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-microsoft\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-microsoft.srs\"\n        },\n        {\n            rule: settings.bypassOracle,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-oracle\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-oracle.srs\"\n        },\n        {\n            rule: settings.bypassDocker,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-docker\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-docker.srs\"\n        },\n        {\n            rule: settings.bypassAdobe,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-adobe\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-adobe.srs\"\n        },\n        {\n            rule: settings.bypassEpicGames,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-epicgames\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-epicgames.srs\"\n        },\n        {\n            rule: settings.bypassIntel,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-intel\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-intel.srs\"\n        },\n        {\n            rule: settings.bypassAmd,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-amd\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-amd.srs\"\n        },\n        {\n            rule: settings.bypassNvidia,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-nvidia\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-nvidia.srs\"\n        },\n        {\n            rule: settings.bypassAsus,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-asus\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-asus.srs\"\n        },\n        {\n            rule: settings.bypassHp,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-hp\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-hp.srs\"\n        },\n        {\n            rule: settings.bypassLenovo,\n            type: 'direct',\n            dns: \"dns-anti-sanction\",\n            geosite: \"geosite-lenovo\",\n            geositeURL: \"https://raw.githubusercontent.com/Chocolate4U/Iran-sing-box-rules/rule-set/geosite-lenovo.srs\"\n        },\n    ];\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/configs/utils.js","messages":[{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":6,"column":27,"nodeType":"Literal","endLine":6,"endColumn":72},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":28,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":28,"endColumn":37},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":56,"column":24,"nodeType":"MemberExpression","endLine":56,"endColumn":42},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":62,"column":21,"nodeType":"MemberExpression","endLine":62,"endColumn":39},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":82,"column":41,"nodeType":"MemberExpression","endLine":82,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":82,"column":64,"nodeType":"MemberExpression","endLine":82,"endColumn":70},{"ruleId":"no-undef","severity":2,"message":"'btoa' is not defined.","line":109,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":109,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":113,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":113,"endColumn":30},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":126,"column":25,"nodeType":"Literal","endLine":126,"endColumn":474},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":132,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":132,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'btoa' is not defined.","line":149,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'TextEncoder' is not defined.","line":149,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":149,"endColumn":55},{"ruleId":"security/detect-unsafe-regex","severity":1,"message":"Unsafe Regular Expression","line":153,"column":19,"nodeType":"Literal","endLine":153,"endColumn":74},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":178,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":178,"endColumn":16}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { globalConfig, httpConfig } from \"#common/init\";\nimport { settings } from '#common/handlers'\n\nexport function isDomain(address) {\n    if (!address) return false;\n    const domainPattern = /^(?!-)(?:[A-Za-z0-9-]{1,63}.)+[A-Za-z]{2,}$/;\n    return domainPattern.test(address);\n}\n\nexport async function resolveDNS(domain, onlyIPv4 = false) {\n    const dohBaseURL = `${globalConfig.dohURL}?name=${encodeURIComponent(domain)}`;\n    const dohURLs = {\n        ipv4: `${dohBaseURL}&type=A`,\n        ipv6: `${dohBaseURL}&type=AAAA`,\n    };\n\n    try {\n        const ipv4 = await fetchDNSRecords(dohURLs.ipv4, 1);\n        const ipv6 = onlyIPv4 ? [] : await fetchDNSRecords(dohURLs.ipv6, 28);\n        return { ipv4, ipv6 };\n    } catch (error) {\n        throw new Error(`Error resolving DNS for ${domain}: ${error.message}`);\n    }\n}\n\nasync function fetchDNSRecords(url, recordType) {\n    try {\n        const response = await fetch(url, { headers: { accept: 'application/dns-json' } });\n        const data = await response.json();\n\n        if (!data.Answer) return [];\n\n        return data.Answer\n            .filter(record => record.type === recordType)\n            .map(record => record.data);\n    } catch (error) {\n        throw new Error(`Failed to fetch DNS records from ${url}: ${error.message}`);\n    }\n}\n\nexport async function getConfigAddresses(isFragment) {\n    const resolved = await resolveDNS(httpConfig.hostName, !settings.VLTRenableIPv6);\n    const addrs = [\n        httpConfig.hostName,\n        'www.speedtest.net',\n        ...resolved.ipv4,\n        ...resolved.ipv6.map((ip) => `[${ip}]`),\n        ...settings.cleanIPs\n    ];\n\n    return isFragment ? addrs : [...addrs, ...settings.customCdnAddrs];\n}\n\nexport function extractWireguardParams(warpConfigs, isWoW) {\n    const index = isWoW ? 1 : 0;\n    const warpConfig = warpConfigs[index].account.config;\n\n    return {\n        warpIPv6: `${warpConfig.interface.addresses.v6}/128`,\n        reserved: warpConfig.client_id,\n        publicKey: warpConfig.peers[0].public_key,\n        privateKey: warpConfigs[index].privateKey,\n    };\n}\n\nexport function generateRemark(index, port, address, protocol, configType, isChain) {\n    let addressType;\n    const chainSign = isChain ? '🔗 ' : '';\n    const type = configType ? ` ${configType}` : '';\n\n    settings.cleanIPs.includes(address)\n        ? addressType = 'Clean IP'\n        : addressType = isDomain(address) ? 'Domain' : isIPv4(address) ? 'IPv4' : isIPv6(address) ? 'IPv6' : '';\n\n    return `💦 ${index} - ${chainSign}${protocol}${type} - ${addressType} : ${port}`;\n}\n\nexport function randomUpperCase(str) {\n    let result = '';\n\n    for (let i = 0; i < str.length; i++) {\n        result += Math.random() < 0.5 ? str[i].toUpperCase() : str[i];\n    }\n\n    return result;\n}\n\nexport function getRandomString(lengthMin, lengthMax) {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    const length = Math.floor(Math.random() * (lengthMax - lengthMin + 1)) + lengthMin;\n\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n\n    return result;\n}\n\nexport function generateWsPath(protocol) {\n    const config = {\n        junk: getRandomString(8, 16),\n        protocol: protocol,\n        mode: settings.proxyIPMode,\n        panelIPs: settings.proxyIPMode === 'proxyip' ? settings.proxyIPs : settings.prefixes\n    };\n\n    return `/${btoa(JSON.stringify(config))}`;\n}\n\nexport function base64ToDecimal(base64) {\n    const binaryString = atob(base64);\n    const hexString = Array.from(binaryString).map(char => char.charCodeAt(0).toString(16).padStart(2, '0')).join('');\n    const decimalArray = hexString.match(/.{2}/g).map(hex => parseInt(hex, 16));\n\n    return decimalArray;\n}\n\nexport function isIPv4(address) {\n    const ipv4Pattern = /^(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(?:\\/([0-9]|[1-2][0-9]|3[0-2]))?$/;\n    return ipv4Pattern.test(address);\n}\n\nexport function isIPv6(address) {\n    const ipv6Pattern = /^\\[(?:(?:[a-fA-F0-9]{1,4}:){7}[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,7}:|::(?:[a-fA-F0-9]{1,4}:){0,7}|(?:[a-fA-F0-9]{1,4}:){1,6}:[a-fA-F0-9]{1,4}|(?:[a-fA-F0-9]{1,4}:){1,5}(?::[a-fA-F0-9]{1,4}){1,2}|(?:[a-fA-F0-9]{1,4}:){1,4}(?::[a-fA-F0-9]{1,4}){1,3}|(?:[a-fA-F0-9]{1,4}:){1,3}(?::[a-fA-F0-9]{1,4}){1,4}|(?:[a-fA-F0-9]{1,4}:){1,2}(?::[a-fA-F0-9]{1,4}){1,5}|[a-fA-F0-9]{1,4}:(?::[a-fA-F0-9]{1,4}){1,6})\\](?:\\/(1[0-1][0-9]|12[0-8]|[0-9]?[0-9]))?$/;\n    return ipv6Pattern.test(address);\n}\n\nexport function getDomain(url) {\n    try {\n        const newUrl = new URL(url);\n        const host = newUrl.hostname;\n        const isHostDomain = isDomain(host);\n\n        return {\n            host,\n            isHostDomain\n        };\n    } catch {\n        return {\n            host: null,\n            isHostDomain: false\n        };\n    }\n}\n\nexport function base64EncodeUnicode(str) {\n    return btoa(String.fromCharCode(...new TextEncoder().encode(str)));\n}\n\nexport function parseHostPort(input, brackets) {\n    const regex = /^(?:\\[(?<ipv6>.+?)\\]|(?<host>[^:]+))(:(?<port>\\d+))?$/;\n    const match = input.match(regex);\n\n    if (!match) return null;\n\n    let ipv6 = match.groups.ipv6;\n\n    if (brackets && ipv6) {\n        ipv6 = `[${ipv6}]`;\n    }\n\n    const host = ipv6 || match.groups.host;\n    const port = match.groups.port ? parseInt(match.groups.port, 10) : null;\n\n    return { host, port };\n}\n\nexport function isHttps(port) {\n    return httpConfig.defaultHttpsPorts.includes(port);\n}\n\nexport async function parseChainProxy(env, buildOutbound) {\n    try {\n        return buildOutbound();\n    } catch (error) {\n        console.log('An error occured while parsing chain proxy: ', error);\n        const settings = await env.kv.get(\"proxySettings\", { type: 'json' });\n        await env.kv.put(\"proxySettings\", JSON.stringify({\n            ...settings,\n            outProxy: '',\n            outProxyParams: {}\n        }));\n\n        return undefined;\n    }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/configs/xray.js","messages":[{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":32,"column":9,"nodeType":"MemberExpression","endLine":32,"endColumn":22},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":47,"column":9,"nodeType":"MemberExpression","endLine":47,"endColumn":24},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":53,"column":9,"nodeType":"MemberExpression","endLine":53,"endColumn":35},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":74,"column":9,"nodeType":"MemberExpression","endLine":74,"endColumn":35},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":266,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":266,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":326,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":326,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":467,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":467,"endColumn":14},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":486,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":486,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":502,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":502,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":521,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":521,"endColumn":26},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":647,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":647,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":825,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":825,"endColumn":42},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":831,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":831,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":886,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":886,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":887,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":887,"endColumn":39},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":907,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":907,"endColumn":51},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":916,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":916,"endColumn":46},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":929,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":929,"endColumn":50},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":948,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":948,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":984,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":984,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'structuredClone' is not defined.","line":988,"column":23,"nodeType":"Identifier","messageId":"undef","endLine":988,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":1002,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":1002,"endColumn":24}],"suppressedMessages":[],"errorCount":18,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDataset } from '#kv';\nimport { globalConfig, httpConfig } from '#common/init';\nimport { settings } from '#common/handlers'\nimport {\n    getConfigAddresses,\n    extractWireguardParams,\n    base64ToDecimal,\n    generateRemark,\n    randomUpperCase,\n    resolveDNS,\n    isDomain,\n    isHttps,\n    getDomain,\n    generateWsPath,\n    parseChainProxy\n} from '#configs/utils';\n\nasync function buildDNS(outboundAddrs, domainToStaticIPs, isWorkerLess, isWarp, customDns, customDnsHosts) {\n    function buildDnsServer(address, domains, expectIPs, skipFallback, tag) {\n        return {\n            address,\n            ...(domains && { domains }),\n            ...(expectIPs && { expectIPs }),\n            ...(skipFallback && { skipFallback }),\n            ...(tag && { tag })\n        };\n    }\n\n    const dnsHost = {};\n    if (settings.dohHost.isDomain && !isWorkerLess && !isWarp) {\n        const { ipv4, ipv6, host } = settings.dohHost;\n        dnsHost[host] = settings.VLTRenableIPv6 ? [...ipv4, ...ipv6] : ipv4;\n    }\n\n    const routingRules = getGeoRules();\n    const blockRules = routingRules.filter(({ type }) => type === 'block');\n\n    settings.customBlockRules.forEach(value => {\n        isDomain(value) && blockRules.push({\n            rule: true,\n            domain: value\n        });\n    });\n\n    for (const { rule, domain } of blockRules) {\n        if (!rule) continue;\n        dnsHost[domain] = [\"127.0.0.1\"];\n    }\n\n    const staticIPs = domainToStaticIPs ? await resolveDNS(domainToStaticIPs, !settings.VLTRenableIPv6) : undefined;\n\n    if (staticIPs) {\n        dnsHost[domainToStaticIPs] = [...staticIPs.ipv4, ...staticIPs.ipv6];\n    }\n\n    const hosts = Object.keys(dnsHost).length ? { hosts: dnsHost } : {};\n    const isIPv6 = (settings.VLTRenableIPv6 && !isWarp) || (settings.warpEnableIPv6 && isWarp);\n    const dnsObject = {\n        ...hosts,\n        servers: [],\n        queryStrategy: !isWarp || isIPv6 ? \"UseIP\" : \"UseIPv4\",\n        tag: \"dns\",\n    };\n\n    let skipFallback = true;\n    let finalRemoteDNS = isWarp ? \"1.1.1.1\" : settings.remoteDNS;\n\n    if (isWorkerLess) {\n        if (!dnsObject.hosts) {\n            dnsObject.hosts = {};\n        }\n\n        finalRemoteDNS = `https://${customDns}/dns-query`;\n        dnsObject.hosts[customDns] = customDnsHosts;\n        skipFallback = false;\n        dnsObject.disableFallbackIfMatch = true;\n    }\n\n    const remoteDnsServer = buildDnsServer(finalRemoteDNS, null, null, null, \"remote-dns\");\n    dnsObject.servers.push(remoteDnsServer);\n\n    const bypassRules = routingRules.filter(({ type }) => type === 'direct');\n\n    if (isDomain(customDnsHosts?.[0])) {\n        bypassRules.push({\n            rule: true,\n            domain: `full:${customDnsHosts[0]}`,\n            dns: settings.localDNS\n        });\n    }\n\n    outboundAddrs.forEach(value => {\n        isDomain(value) && bypassRules.push({\n            rule: true,\n            domain: `full:${value}`,\n            dns: settings.localDNS\n        });\n    });\n\n    settings.customBypassRules.forEach(value => {\n        isDomain(value) && bypassRules.push({\n            rule: true,\n            domain: `domain:${value}`,\n            dns: settings.localDNS\n        });\n    });\n\n    settings.customBypassSanctionRules.forEach(value => {\n        isDomain(value) && bypassRules.push({\n            rule: true,\n            domain: `domain:${value}`,\n            dns: settings.antiSanctionDNS\n        });\n    });\n\n    const { host, isHostDomain } = getDomain(settings.antiSanctionDNS);\n\n    if (isHostDomain) {\n        bypassRules.push({ rule: true, domain: `full:${host}`, dns: settings.localDNS });\n    }\n\n    const totalDomainRules = [];\n    const groupedDomainRules = new Map();\n\n    for (const { rule, domain, ip, dns } of bypassRules) {\n        if (!rule) continue;\n\n        if (ip) {\n            const server = buildDnsServer(dns, [domain], [ip], skipFallback);\n            dnsObject.servers.push(server);\n        } else {\n            if (!groupedDomainRules.has(dns)) groupedDomainRules.set(dns, []);\n            groupedDomainRules.get(dns).push(domain);\n        }\n\n        if (domain) totalDomainRules.push(domain);\n    }\n\n    for (const [dns, domain] of groupedDomainRules) {\n        if (domain.length) {\n            const server = buildDnsServer(dns, domain, null, skipFallback);\n            dnsObject.servers.push(server);\n        }\n    }\n\n    const isFakeDNS = (settings.VLTRFakeDNS && !isWarp) || (settings.warpFakeDNS && isWarp);\n\n    if (isFakeDNS) {\n        const fakeDNSServer = totalDomainRules.length\n            ? buildDnsServer(\"fakedns\", totalDomainRules, null, false)\n            : \"fakedns\";\n        dnsObject.servers.unshift(fakeDNSServer);\n    }\n\n    return dnsObject;\n}\n\nfunction buildRoutingRules(isChain, isBalancer, isWorkerLess, isWarp) {\n    const rules = [\n        {\n            inboundTag: [\n                \"mixed-in\"\n            ],\n            port: 53,\n            outboundTag: \"dns-out\",\n            type: \"field\"\n        },\n        {\n            inboundTag: [\n                \"dns-in\"\n            ],\n            outboundTag: \"dns-out\",\n            type: \"field\"\n        }\n    ];\n\n    const addRoutingRule = (inboundTag, domain, ip, port, network, protocol, outboundTag, isBalancer) => rules.push({\n        ...(inboundTag && { inboundTag }),\n        ...(domain && { domain }),\n        ...(ip && { ip }),\n        ...(port && { port }),\n        ...(network && { network }),\n        ...(protocol && { protocol: [protocol] }),\n        ...(isBalancer\n            ? { balancerTag: outboundTag }\n            : { outboundTag }),\n        type: \"field\"\n    });\n\n    const finallOutboundTag = isChain ? \"chain\" : isWorkerLess ? \"direct\" : \"proxy\";\n    const outTag = isBalancer ? isChain ? \"all-chains\" : \"all\" : finallOutboundTag;\n    const remoteDnsProxy = isBalancer ? \"all\" : \"proxy\";\n\n    addRoutingRule([\"remote-dns\"], null, null, null, null, null, remoteDnsProxy, isBalancer);\n    addRoutingRule([\"dns\"], null, null, null, null, null, \"direct\");\n\n    addRoutingRule(null, [\"geosite:private\"], null, null, null, null, \"direct\");\n    addRoutingRule(null, null, [\"geoip:private\"], null, null, null, \"direct\");\n\n    if (isWarp && settings.blockUDP443) {\n        addRoutingRule(null, null, null, 443, \"udp\", null, \"block\");\n    }\n\n    if (!isWarp && !isWorkerLess) {\n        addRoutingRule(null, null, null, null, \"udp\", null, \"block\", null);\n    }\n\n    const routingRules = getGeoRules();\n    const bypassRules = [\n        ...settings.customBypassRules,\n        ...settings.customBypassSanctionRules\n    ];\n\n    bypassRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n        routingRules.push({\n            rule: true,\n            type: 'direct',\n            domain: isDomainValue ? `domain:${value}` : null,\n            ip: isDomainValue ? null : value\n        });\n    });\n\n    settings.customBlockRules.forEach(value => {\n        const isDomainValue = isDomain(value);\n        routingRules.push({\n            rule: true,\n            type: 'block',\n            domain: isDomainValue ? `domain:${value}` : null,\n            ip: isDomainValue ? null : value\n        });\n    });\n\n    const groupedRules = new Map();\n\n    for (const { rule, type, ip, domain } of routingRules) {\n        if (!rule) continue;\n        if (!groupedRules.has(type)) groupedRules.set(type, { domain: [], ip: [] });\n        if (domain) groupedRules.get(type).domain.push(domain);\n        if (ip) groupedRules.get(type).ip.push(ip);\n    }\n\n    for (const [type, rule] of groupedRules) {\n        const { domain, ip } = rule;\n        if (domain.length) addRoutingRule(null, domain, null, null, null, null, type, null);\n        if (ip.length) addRoutingRule(null, null, ip, null, null, null, type, null);\n    }\n\n    if (isWorkerLess) {\n        addRoutingRule(null, null, null, null, \"tcp\", \"tls\", \"proxy\");\n        addRoutingRule(null, null, null, null, \"tcp\", \"http\", \"http-fragment\");\n        addRoutingRule(null, null, null, null, \"udp\", \"quic\", \"udp-noise\");\n        addRoutingRule(null, null, null, \"443,2053,2083,2087,2096,8443\", \"udp\", null, \"udp-noise\");\n    }\n\n    const network = isWarp || isWorkerLess ? \"tcp,udp\" : \"tcp\";\n    addRoutingRule(null, null, null, null, network, null, outTag, isBalancer);\n\n    return rules;\n}\n\nfunction buildVLOutbound(tag, address, port, host, sni, isFragment, allowInsecure) {\n    const path = `${generateWsPath(\"vl\")}?ed=2560`;\n\n    const outbound = {\n        protocol: atob('dmxlc3M='),\n        settings: {\n            vnext: [\n                {\n                    address: address,\n                    port: port,\n                    users: [\n                        {\n                            id: globalConfig.userID,\n                            encryption: \"none\",\n                            level: 8\n                        }\n                    ]\n                }\n            ]\n        },\n        streamSettings: {\n            network: \"ws\",\n            security: \"none\",\n            sockopt: {},\n            wsSettings: {\n                host: host,\n                path,\n            }\n        },\n        tag: tag\n    };\n\n    if (isHttps(port)) {\n        outbound.streamSettings.security = \"tls\";\n        outbound.streamSettings.tlsSettings = {\n            allowInsecure: allowInsecure,\n            fingerprint: settings.fingerprint,\n            alpn: [\"http/1.1\"],\n            serverName: sni\n        };\n    }\n\n    const sockopt = outbound.streamSettings.sockopt;\n\n    if (isFragment) {\n        sockopt.dialerProxy = \"fragment\";\n    } else {\n        sockopt.domainStrategy = \"UseIP\";\n        sockopt.tcpFastOpen = true;\n        sockopt.happyEyeballs = {\n            tryDelayMs: 250,\n            prioritizeIPv6: false,\n            interleave: 2,\n            maxConcurrentTry: 4\n        };\n    }\n\n    return outbound;\n}\n\nfunction buildTROutbound(tag, address, port, host, sni, isFragment, allowInsecure) {\n    const path = `${generateWsPath(\"tr\")}?ed=2560`;\n\n    const outbound = {\n        protocol: atob('dHJvamFu'),\n        settings: {\n            servers: [\n                {\n                    address: address,\n                    port: port,\n                    password: globalConfig.TrPass,\n                    level: 8\n                }\n            ]\n        },\n        streamSettings: {\n            network: \"ws\",\n            security: \"none\",\n            sockopt: {},\n            wsSettings: {\n                host: host,\n                path\n            }\n        },\n        tag: tag\n    };\n\n    if (isHttps(port)) {\n        outbound.streamSettings.security = \"tls\";\n        outbound.streamSettings.tlsSettings = {\n            allowInsecure: allowInsecure,\n            fingerprint: settings.fingerprint,\n            alpn: [\"http/1.1\"],\n            serverName: sni\n        };\n    }\n\n    const sockopt = outbound.streamSettings.sockopt;\n\n    if (isFragment) {\n        sockopt.dialerProxy = \"fragment\";\n    } else {\n        sockopt.domainStrategy = \"UseIP\";\n        sockopt.tcpFastOpen = true;\n        sockopt.happyEyeballs = {\n            tryDelayMs: 250,\n            prioritizeIPv6: false,\n            interleave: 2,\n            maxConcurrentTry: 4\n        };\n    }\n\n    return outbound;\n}\n\nfunction buildWarpOutbound(warpConfigs, endpoint, isWoW, isPro) {\n    const {\n        warpIPv6,\n        reserved,\n        publicKey,\n        privateKey\n    } = extractWireguardParams(warpConfigs, isWoW);\n\n    const outbound = {\n        protocol: \"wireguard\",\n        settings: {\n            address: [\n                \"172.16.0.2/32\",\n                warpIPv6\n            ],\n            mtu: 1280,\n            peers: [\n                {\n                    endpoint: isWoW ? \"162.159.192.1:2408\" : endpoint,\n                    publicKey: publicKey,\n                    keepAlive: 5\n                }\n            ],\n            reserved: base64ToDecimal(reserved),\n            secretKey: privateKey\n        },\n        tag: isWoW ? \"chain\" : \"proxy\"\n    };\n\n    let chain = '';\n    if (isWoW) chain = \"proxy\";\n    if (!isWoW && isPro && httpConfig.client === 'xray') chain = \"udp-noise\";\n\n    if (chain) outbound.streamSettings = {\n        sockopt: {\n            dialerProxy: chain\n        }\n    };\n\n    if (httpConfig.client === 'xray-knocker' && !isWoW) {\n        const {\n            knockerNoiseMode,\n            noiseCountMin,\n            noiseCountMax,\n            noiseSizeMin,\n            noiseSizeMax,\n            noiseDelayMin,\n            noiseDelayMax\n        } = settings;\n\n        Object.assign(outbound.settings, {\n            wnoise: knockerNoiseMode,\n            wnoisecount: noiseCountMin === noiseCountMax\n                ? String(noiseCountMin)\n                : `${noiseCountMin}-${noiseCountMax}`,\n            wpayloadsize: noiseSizeMin === noiseSizeMax\n                ? String(noiseSizeMin)\n                : `${noiseSizeMin}-${noiseSizeMax}`,\n            wnoisedelay: noiseDelayMin === noiseDelayMax\n                ? String(noiseDelayMin)\n                : `${noiseDelayMin}-${noiseDelayMax}`\n        });\n    }\n\n    return outbound;\n}\n\nfunction buildChainOutbound() {\n    const { outProxyParams } = settings;\n    const { protocol, security, type, server, port } = outProxyParams;\n\n    const outbound = {\n        protocol: protocol,\n        mux: {\n            enabled: true,\n            concurrency: 8,\n            xudpConcurrency: 16,\n            xudpProxyUDP443: \"reject\"\n        },\n        settings: {},\n        streamSettings: {\n            network: type || \"raw\",\n            security,\n            sockopt: {\n                dialerProxy: \"proxy\"\n            }\n        },\n        tag: \"chain\"\n    };\n\n    if ([atob('c29ja3M='), 'http'].includes(protocol)) {\n        const { user, pass } = outProxyParams;\n        outbound.settings.servers = [\n            {\n                address: server,\n                port,\n                users: [\n                    {\n                        user: user,\n                        pass: pass,\n                        level: 8\n                    }\n                ]\n            }\n        ];\n\n        return outbound;\n    }\n\n    if (protocol === atob('c2hhZG93c29ja3M=')) {\n        const { password, method } = outProxyParams;\n        outbound.settings.servers = [\n            {\n                address: server,\n                method,\n                ota: false,\n                password,\n                port,\n                level: 8\n            }\n        ];\n\n        return outbound;\n    }\n\n    if (protocol === atob('dmxlc3M=')) {\n        const { uuid, flow } = outProxyParams;\n        outbound.settings.vnext = [\n            {\n                address: server,\n                port,\n                users: [\n                    {\n                        encryption: \"none\",\n                        flow: flow,\n                        id: uuid,\n                        level: 8,\n                        security: \"auto\"\n                    }\n                ]\n            }\n        ];\n    }\n\n    if (protocol === atob('dHJvamFu')) {\n        const { password } = outProxyParams;\n        outbound.settings.servers = [\n            {\n                address: server,\n                port,\n                password,\n                level: 8\n            }\n        ];\n    }\n\n    const {\n        sni, fp, alpn, pbk, sid, spx, headerType,\n        host, path, authority, serviceName, mode\n    } = outProxyParams;\n\n    if (security === 'tls') {\n        const tlsAlpns = alpn ? alpn?.split(',') : [];\n        outbound.streamSettings.tlsSettings = {\n            allowInsecure: false,\n            fingerprint: fp,\n            alpn: tlsAlpns,\n            serverName: sni\n        };\n    }\n\n    if (security === 'reality') {\n        delete outbound.mux;\n        outbound.streamSettings.realitySettings = {\n            fingerprint: fp,\n            publicKey: pbk,\n            serverName: sni,\n            shortId: sid,\n            spiderX: spx\n        };\n    }\n\n    if (headerType === 'http') {\n        const httpPaths = path?.split(',');\n        const httpHosts = host?.split(',');\n        outbound.streamSettings.tcpSettings = {\n            header: {\n                request: {\n                    headers: { Host: httpHosts },\n                    method: \"GET\",\n                    path: httpPaths,\n                    version: \"1.1\"\n                },\n                response: {\n                    headers: { \"Content-Type\": [\"application/octet-stream\"] },\n                    reason: \"OK\",\n                    status: \"200\",\n                    version: \"1.1\"\n                },\n                type: \"http\"\n            }\n        };\n    }\n\n    if (['tcp', 'raw'].includes(type) && security !== 'reality' && !headerType) outbound.streamSettings.rawSettings = {\n        header: {\n            type: \"none\"\n        }\n    };\n\n    if (type === 'ws') outbound.streamSettings.wsSettings = {\n        host: host,\n        path: path\n    };\n\n    if (type === 'httpupgrade') outbound.streamSettings.httpupgradeSettings = {\n        host: host,\n        path: path\n    };\n\n    if (type === 'grpc') {\n        delete outbound.mux;\n        outbound.streamSettings.grpcSettings = {\n            authority: authority,\n            multiMode: mode === 'multi',\n            serviceName: serviceName\n        };\n    }\n\n    return outbound;\n}\n\nfunction buildFreedomOutbound(isFragment, isUdpNoises, tag, length, interval) {\n    const outbound = {\n        tag: tag,\n        protocol: \"freedom\",\n        settings: {},\n    };\n\n    if (isFragment) {\n        const {\n            fragmentPackets,\n            fragmentLengthMin,\n            fragmentLengthMax,\n            fragmentIntervalMin,\n            fragmentIntervalMax\n        } = settings;\n\n        outbound.settings.fragment = {\n            packets: fragmentPackets,\n            length: length || `${fragmentLengthMin}-${fragmentLengthMax}`,\n            interval: interval || `${fragmentIntervalMin}-${fragmentIntervalMax}`,\n        };\n\n        outbound.streamSettings = {\n            sockopt: {\n                tcpFastOpen: true,\n                domainStrategy: \"UseIP\",\n                happyEyeballs: {\n                    tryDelayMs: 250,\n                    prioritizeIPv6: false,\n                    interleave: 2,\n                    maxConcurrentTry: 4\n                }\n            }\n        };\n    }\n\n    if (isUdpNoises) {\n        outbound.settings.noises = [];\n        const noises = structuredClone(settings.xrayUdpNoises);\n        noises.forEach(noise => {\n            const count = noise.count;\n            delete noise.count;\n            outbound.settings.noises.push(...Array.from({ length: count }, () => noise));\n        });\n\n        if (!isFragment) {\n            outbound.settings.domainStrategy = settings.warpEnableIPv6 ? \"UseIPv4v6\" : \"UseIPv4\";\n        }\n    }\n\n    return outbound;\n}\n\nasync function buildConfig(\n    remark,\n    outbounds,\n    isBalancer,\n    isChain,\n    balancerFallback,\n    isWarp,\n    isWorkerLess,\n    outboundAddrs,\n    domainToStaticIPs,\n    customDns,\n    customDnsHosts\n) {\n    const isFakeDNS = (settings.VLTRFakeDNS && !isWarp) || (settings.warpFakeDNS && isWarp);\n    const config = {\n        remarks: remark,\n        log: {\n            loglevel: \"warning\",\n        },\n        dns: await buildDNS(outboundAddrs, domainToStaticIPs, isWorkerLess, isWarp, customDns, customDnsHosts),\n        inbounds: [\n            {\n                port: 10808,\n                protocol: \"socks\",\n                settings: {\n                    auth: \"noauth\",\n                    udp: true,\n                    userLevel: 8,\n                },\n                sniffing: {\n                    destOverride: [\n                        \"http\",\n                        \"tls\",\n                        ...(isWorkerLess ? [\"quic\"] : []),\n                        ...(isFakeDNS ? [\"fakedns\"] : [])\n                    ],\n                    enabled: true,\n                    routeOnly: true\n                },\n                tag: \"mixed-in\",\n            },\n            {\n                port: 10853,\n                protocol: \"dokodemo-door\",\n                settings: {\n                    address: \"1.1.1.1\",\n                    network: \"tcp,udp\",\n                    port: 53\n                },\n                tag: \"dns-in\"\n            }\n        ],\n        outbounds: [\n            ...outbounds,\n            {\n                protocol: \"dns\",\n                tag: \"dns-out\"\n            },\n            {\n                protocol: \"freedom\",\n                settings: {\n                    domainStrategy: \"UseIP\"\n                },\n                tag: \"direct\",\n            },\n            {\n                protocol: \"blackhole\",\n                settings: {\n                    response: {\n                        type: \"http\",\n                    },\n                },\n                tag: \"block\",\n            },\n        ],\n        policy: {\n            levels: {\n                8: {\n                    connIdle: 300,\n                    downlinkOnly: 1,\n                    handshake: 4,\n                    uplinkOnly: 1,\n                }\n            },\n            system: {\n                statsOutboundUplink: true,\n                statsOutboundDownlink: true,\n            }\n        },\n        routing: {\n            domainStrategy: \"IPIfNonMatch\",\n            rules: buildRoutingRules(isChain, isBalancer, isWorkerLess, isWarp),\n        },\n        stats: {}\n    };\n\n    if (isBalancer) {\n        const createBalancer = (tag, selector, hasFallback) => {\n            return {\n                tag,\n                selector: [selector],\n                strategy: {\n                    type: \"leastPing\",\n                },\n                ...(hasFallback && { fallbackTag: \"proxy-2\" })\n            };\n        }\n\n        config.routing.balancers = [createBalancer(\"all\", \"proxy\", balancerFallback)];\n\n        if (isChain) {\n            const chainBalancer = createBalancer(\"all-chains\", \"chain\", false)\n            config.routing.balancers.push(chainBalancer);\n        }\n\n        config.observatory = {\n            subjectSelector: isChain ? [\"chain\", \"proxy\"] : [\"proxy\"],\n            probeUrl: \"https://www.gstatic.com/generate_204\",\n            probeInterval: `${isWarp\n                ? settings.bestWarpInterval\n                : settings.bestVLTRInterval\n                }s`,\n            enableConcurrency: true\n        };\n    }\n\n    return config;\n}\n\nasync function addBestPingConfigs(configs, totalAddresses, proxyOutbounds, chainOutbounds, isFragment) {\n    const isChain = chainOutbounds.length;\n    const chainSign = isChain ? '🔗 ' : '';\n    const remark = `💦 ${chainSign}Best Ping 🚀`;\n    const outbounds = [\n        ...chainOutbounds,\n        ...proxyOutbounds\n    ];\n\n    if (isFragment) {\n        const fragmentOutbound = buildFreedomOutbound(true, false, 'fragment');\n        outbounds.push(fragmentOutbound);\n    }\n\n    const config = await buildConfig(remark, outbounds, true, isChain, true, false, false, totalAddresses, null);\n\n    if (isChain) {\n        await addBestPingConfigs(configs, totalAddresses, proxyOutbounds, [], isFragment);\n    }\n\n    configs.push(config);\n}\n\nasync function addBestFragmentConfigs(configs, chainProxy, outbound) {\n    const bestFragValues = [\n        '10-20', '20-30', '30-40', '40-50', '50-60', '60-70',\n        '70-80', '80-90', '90-100', '10-30', '20-40', '30-50',\n        '40-60', '50-70', '60-80', '70-90', '80-100', '100-200'\n    ];\n\n    const outbounds = [];\n\n    bestFragValues.forEach((fragLength, index) => {\n        if (chainProxy) {\n            const chain = structuredClone(chainProxy);\n            chain.tag = `chain-${index + 1}`;\n            chain.streamSettings.sockopt.dialerProxy = `proxy-${index + 1}`;\n            outbounds.push(chain);\n        }\n\n        const proxy = structuredClone(outbound);\n        proxy.tag = `proxy-${index + 1}`;\n        proxy.streamSettings.sockopt.dialerProxy = `fragment-${index + 1}`;\n        const fragInterval = `${settings.fragmentIntervalMin}-${settings.fragmentIntervalMax}`;\n        const fragment = buildFreedomOutbound(true, false, `fragment-${index + 1}`, fragLength, fragInterval);\n        outbounds.push(proxy, fragment);\n    });\n\n    const chainSign = chainProxy ? '🔗 ' : '';\n    const config = await buildConfig(\n        `💦 ${chainSign}Best Fragment 😎`,\n        outbounds,\n        true,\n        chainProxy,\n        false,\n        false,\n        false,\n        [],\n        httpConfig.hostName\n    );\n\n    if (chainProxy) {\n        await addBestFragmentConfigs(configs, false, outbound);\n    }\n\n    configs.push(config);\n}\n\nasync function addWorkerlessConfigs(configs) {\n    const tlsFragment = buildFreedomOutbound(true, false, 'proxy');\n    const udpNoise = buildFreedomOutbound(false, true, 'udp-noise');\n    const httpFragment = buildFreedomOutbound(true, false, 'http-fragment');\n    httpFragment.settings.fragment.packets = \"1-1\";\n    const outbounds = [\n        tlsFragment,\n        httpFragment,\n        udpNoise\n    ];\n\n    const cfDnsConfig = await buildConfig(`💦 1 - Workerless ⭐`, outbounds, false, false, false, false, true, [], false, \"cloudflare-dns.com\", [\"cloudflare.com\"]);\n    const googleDnsConfig = await buildConfig(`💦 2 - Workerless ⭐`, outbounds, false, false, false, false, true, [], false, \"dns.google\", [\"8.8.8.8\", \"8.8.4.4\"]);\n    configs.push(cfDnsConfig, googleDnsConfig);\n}\n\nexport async function getXrCustomConfigs(env, isFragment) {\n    let chainProxy;\n\n    if (settings.outProxy) {\n        chainProxy = await parseChainProxy(env, buildChainOutbound);\n    }\n\n\n    const Addresses = await getConfigAddresses(isFragment);\n    const totalPorts = settings.ports.filter(port => isFragment ? isHttps(port) : true);\n    const protocols = [\n        ...(settings.VLConfigs ? [atob('VkxFU1M=')] : []),\n        ...(settings.TRConfigs ? [atob('VHJvamFu')] : [])\n    ];\n\n    const configs = [];\n    const proxies = [], chains = [];\n    let index = 1;\n\n    const fragment = isFragment\n        ? [buildFreedomOutbound(true, false, 'fragment')]\n        : [];\n\n    for (const protocol of protocols) {\n        let protocolIndex = 1;\n        for (const port of totalPorts) {\n            for (const addr of Addresses) {\n                const isCustomAddr = settings.customCdnAddrs.includes(addr) && !isFragment;\n                const sni = isCustomAddr ? settings.customCdnSni : randomUpperCase(httpConfig.hostName);\n                const host = isCustomAddr ? settings.customCdnHost : httpConfig.hostName;\n                const configType = isCustomAddr ? 'C' : isFragment ? 'F' : '';\n\n                const outbound = protocol === atob('VkxFU1M=')\n                    ? buildVLOutbound('proxy', addr, port, host, sni, isFragment, isCustomAddr)\n                    : buildTROutbound('proxy', addr, port, host, sni, isFragment, isCustomAddr);\n\n                const outbounds = [\n                    outbound,\n                    ...fragment\n                ];\n\n                const proxy = structuredClone(outbound);\n                proxy.tag = `proxy-${index}`\n                proxies.push(proxy);\n\n                const remark = generateRemark(protocolIndex, port, addr, protocol, configType, false);\n                const config = await buildConfig(remark, outbounds, false, false, false, false, false, [addr], null);\n                configs.push(config);\n\n                if (chainProxy) {\n                    const remark = generateRemark(protocolIndex, port, addr, protocol, configType, true);\n                    const chainConfig = await buildConfig(remark, [chainProxy, ...outbounds], false, true, false, false, false, [addr], null);\n                    configs.push(chainConfig);\n\n                    const chain = structuredClone(chainProxy);\n                    chain.tag = `chain-${index}`;\n                    chain.streamSettings.sockopt.dialerProxy = `proxy-${index}`;\n                    chains.push(chain);\n                }\n\n                protocolIndex++;\n                index++;\n            }\n        }\n    }\n\n    await addBestPingConfigs(configs, Addresses, proxies, chains, isFragment);\n\n    if (isFragment) {\n        await addBestFragmentConfigs(configs, chainProxy, proxies[0]);\n        await addWorkerlessConfigs(configs);\n    }\n\n    return new Response(JSON.stringify(configs, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nexport async function getXrWarpConfigs(request, env, isPro, isKnocker) {\n    const { warpConfigs } = await getDataset(request, env);\n    const proIndicator = isPro ? ' Pro ' : ' ';\n    const configs = [];\n    const proxies = [], chains = []\n    const udpNoise = isPro && !isKnocker\n        ? [buildFreedomOutbound(false, true, 'udp-noise')]\n        : [];\n\n    for (const [index, endpoint] of settings.warpEndpoints.entries()) {\n        const warpOutbounds = [...udpNoise];\n        const wowOutbounds = [...udpNoise];\n        const endpointHost = endpoint.split(':')[0];\n\n        const warpOutbound = buildWarpOutbound(warpConfigs, endpoint, false, isPro);\n        const wowOutbound = buildWarpOutbound(warpConfigs, endpoint, true, isPro);\n\n        warpOutbounds.unshift(warpOutbound);\n        wowOutbounds.unshift(wowOutbound, warpOutbound);\n\n        const warpConfig = await buildConfig(`💦 ${index + 1} - Warp${proIndicator}🇮🇷`, warpOutbounds, false, false, false, true, false, [endpointHost], null);\n        configs.push(warpConfig);\n        \n        const wowConfig = await buildConfig(`💦 ${index + 1} - WoW${proIndicator}🌍`, wowOutbounds, false, true, false, true, false, [endpointHost], null);\n        configs.push(wowConfig);\n\n        const proxy = structuredClone(warpOutbound);\n        proxy.tag = `proxy-${index + 1}`;\n        proxies.push(proxy);\n\n        const chain = structuredClone(wowOutbound);\n        chain.tag = `chain-${index + 1}`;\n        chain.streamSettings.sockopt.dialerProxy = `proxy-${index + 1}`;\n        chains.push(chain);\n    }\n\n    const outboundDomains = settings.warpEndpoints.map(endpoint => endpoint.split(':')[0]).filter(address => isDomain(address));\n    const warpBestPingOutbounds = [...proxies, ...udpNoise];\n    const wowBestPingOutbounds = [...chains, ...proxies, ...udpNoise];\n\n    const warpBestPing = await buildConfig(`💦 Warp${proIndicator}- Best Ping 🚀`, warpBestPingOutbounds, true, false, false, true, false, outboundDomains, null);\n    const wowBestPing = await buildConfig(`💦 WoW${proIndicator}- Best Ping 🚀`, wowBestPingOutbounds, true, true, false, true, false, outboundDomains, null);\n    configs.push(warpBestPing, wowBestPing);\n\n    return new Response(JSON.stringify(configs, null, 4), {\n        status: 200,\n        headers: {\n            'Content-Type': 'text/plain;charset=utf-8',\n            'Cache-Control': 'no-store',\n            'CDN-Cache-Control': 'no-store'\n        }\n    });\n}\n\nfunction getGeoRules() {\n    return [\n        { rule: settings.blockAds, type: 'block', domain: \"geosite:category-ads-all\" },\n        { rule: settings.blockAds, type: 'block', domain: \"geosite:category-ads-ir\" },\n        { rule: settings.blockPorn, type: 'block', domain: \"geosite:category-porn\" },\n        { rule: settings.bypassIran, type: 'direct', domain: \"geosite:category-ir\", ip: \"geoip:ir\", dns: settings.localDNS },\n        { rule: settings.bypassChina, type: 'direct', domain: \"geosite:cn\", ip: \"geoip:cn\", dns: settings.localDNS },\n        { rule: settings.bypassRussia, type: 'direct', domain: \"geosite:category-ru\", ip: \"geoip:ru\", dns: settings.localDNS },\n        { rule: settings.bypassOpenAi, type: 'direct', domain: \"geosite:openai\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassMicrosoft, type: 'direct', domain: \"geosite:microsoft\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassOracle, type: 'direct', domain: \"geosite:oracle\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassDocker, type: 'direct', domain: \"geosite:docker\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassAdobe, type: 'direct', domain: \"geosite:adobe\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassEpicGames, type: 'direct', domain: \"geosite:epicgames\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassIntel, type: 'direct', domain: \"geosite:intel\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassAmd, type: 'direct', domain: \"geosite:amd\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassNvidia, type: 'direct', domain: \"geosite:nvidia\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassAsus, type: 'direct', domain: \"geosite:asus\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassHp, type: 'direct', domain: \"geosite:hp\", dns: settings.antiSanctionDNS },\n        { rule: settings.bypassLenovo, type: 'direct', domain: \"geosite:lenovo\", dns: settings.antiSanctionDNS },\n    ];\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/kv.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":24,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":24,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":38,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":38,"endColumn":20},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":47,"column":20,"nodeType":"MemberExpression","endLine":47,"endColumn":44},{"ruleId":"security/detect-object-injection","severity":1,"message":"Variable Assigned to Object Injection Sink","line":50,"column":23,"nodeType":"MemberExpression","endLine":50,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":148,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":148,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'URL' is not defined.","line":164,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":164,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":168,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":168,"endColumn":40},{"ruleId":"no-undef","severity":2,"message":"'URLSearchParams' is not defined.","line":174,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":43},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":176,"column":13,"nodeType":"MemberExpression","endLine":176,"endColumn":30},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":181,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":181,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":186,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":186,"endColumn":18},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":191,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":191,"endColumn":18},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":192,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":192,"endColumn":106,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7290,7576],"text":"{ const auth = new TextDecoder().decode(Uint8Array.from(atob(username), c => c.charCodeAt(0)));\n            const [first, ...rest] = auth.split(':');\n            configParams.method = first;\n            configParams.password = rest.join(':');\n            parseParams();\n            break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-undef","severity":2,"message":"'TextDecoder' is not defined.","line":192,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":192,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":71},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":193,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":193,"endColumn":54,"suggestions":[{"messageId":"addBrackets","fix":{"range":[7290,7576],"text":"{ const auth = new TextDecoder().decode(Uint8Array.from(atob(username), c => c.charCodeAt(0)));\n            const [first, ...rest] = auth.split(':');\n            configParams.method = first;\n            configParams.password = rest.join(':');\n            parseParams();\n            break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":199,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":199,"endColumn":18}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { getDomain, resolveDNS } from '#configs/utils';\nimport { httpConfig } from '#common/init';\nimport { fetchWarpConfigs } from '#protocols/warp';\n\nexport async function getDataset(request, env) {\n    let settings, warpConfigs;\n\n    try {\n        settings = await env.kv.get(\"proxySettings\", { type: 'json' });\n        warpConfigs = await env.kv.get('warpConfigs', { type: 'json' });\n\n        if (!settings) {\n            settings = await updateDataset(request, env);\n            const configs = await fetchWarpConfigs(env);\n            warpConfigs = configs;\n        }\n\n        if (httpConfig.panelVersion !== settings.panelVersion) {\n            settings = await updateDataset(request, env);\n        }\n\n        return { settings, warpConfigs }\n    } catch (error) {\n        console.log(error);\n        throw new Error(`An error occurred while getting KV - ${error.message}`);\n    }\n}\n\nexport async function updateDataset(request, env) {\n    let newSettings = request.method === 'POST' ? await request.json() : null;\n    const isReset = newSettings?.resetSettings;\n    let currentSettings;\n\n    if (!isReset) {\n        try {\n            currentSettings = await env.kv.get(\"proxySettings\", { type: 'json' });\n        } catch (error) {\n            console.log(error);\n            throw new Error(`An error occurred while getting current KV settings - ${error}`);\n        }\n    }\n\n    const populateField = (field, defaultValue, callback) => {\n        if (isReset) return defaultValue;\n\n        if (!newSettings) {\n            return currentSettings?.[field] ?? defaultValue;\n        }\n\n        const value = newSettings[field];\n\n        return typeof callback === 'function' ? callback(value) : value;\n    }\n\n    const remoteDNS = populateField('remoteDNS', 'https://8.8.8.8/dns-query');\n    const initDoh = async () => {\n        const { host, isHostDomain } = getDomain(remoteDNS);\n        const dohHost = {\n            host,\n            isDomain: isHostDomain\n        }\n\n        if (isHostDomain) {\n            const { ipv4, ipv6 } = await resolveDNS(host);\n            dohHost.ipv4 = ipv4;\n            dohHost.ipv6 = ipv6;\n        }\n\n        return dohHost;\n    }\n\n    const settings = {\n        remoteDNS,\n        dohHost: await initDoh(),\n        localDNS: populateField('localDNS', '8.8.8.8'),\n        antiSanctionDNS: populateField('antiSanctionDNS', '78.157.42.100'),\n        VLTRFakeDNS: populateField('VLTRFakeDNS', false),\n        proxyIPMode: populateField('proxyIPMode', 'proxyip'),\n        proxyIPs: populateField('proxyIPs', []),\n        prefixes: populateField('prefixes', []),\n        outProxy: populateField('outProxy', ''),\n        outProxyParams: populateField('outProxy', {}, field => extractChainProxyParams(field)),\n        cleanIPs: populateField('cleanIPs', []),\n        VLTRenableIPv6: populateField('VLTRenableIPv6', true),\n        customCdnAddrs: populateField('customCdnAddrs', []),\n        customCdnHost: populateField('customCdnHost', ''),\n        customCdnSni: populateField('customCdnSni', ''),\n        bestVLTRInterval: populateField('bestVLTRInterval', 30),\n        VLConfigs: populateField('VLConfigs', true),\n        TRConfigs: populateField('TRConfigs', true),\n        ports: populateField('ports', [443]),\n        fingerprint: populateField('fingerprint', 'chrome'),\n        fragmentMode: populateField('fragmentMode', 'custom'),\n        fragmentLengthMin: populateField('fragmentLengthMin', 100),\n        fragmentLengthMax: populateField('fragmentLengthMax', 200),\n        fragmentIntervalMin: populateField('fragmentIntervalMin', 1),\n        fragmentIntervalMax: populateField('fragmentIntervalMax', 1),\n        fragmentPackets: populateField('fragmentPackets', 'tlshello'),\n        bypassIran: populateField('bypassIran', false),\n        bypassChina: populateField('bypassChina', false),\n        bypassRussia: populateField('bypassRussia', false),\n        bypassOpenAi: populateField('bypassOpenAi', false),\n        bypassMicrosoft: populateField('bypassMicrosoft', false),\n        bypassOracle: populateField('bypassOracle', false),\n        bypassDocker: populateField('bypassDocker', false),\n        bypassAdobe: populateField('bypassAdobe', false),\n        bypassEpicGames: populateField('bypassEpicGames', false),\n        bypassIntel: populateField('bypassIntel', false),\n        bypassAmd: populateField('bypassAmd', false),\n        bypassNvidia: populateField('bypassNvidia', false),\n        bypassAsus: populateField('bypassAsus', false),\n        bypassHp: populateField('bypassHp', false),\n        bypassLenovo: populateField('bypassLenovo', false),\n        blockAds: populateField('blockAds', false),\n        blockPorn: populateField('blockPorn', false),\n        blockUDP443: populateField('blockUDP443', false),\n        customBypassRules: populateField('customBypassRules', []),\n        customBlockRules: populateField('customBlockRules', []),\n        customBypassSanctionRules: populateField('customBypassSanctionRules', []),\n        warpEndpoints: populateField('warpEndpoints', ['engage.cloudflareclient.com:2408']),\n        warpFakeDNS: populateField('warpFakeDNS', false),\n        warpEnableIPv6: populateField('warpEnableIPv6', true),\n        bestWarpInterval: populateField('bestWarpInterval', 30),\n        xrayUdpNoises: populateField('xrayUdpNoises', [\n            {\n                type: 'rand',\n                packet: '50-100',\n                delay: '1-1',\n                count: 5\n            }\n        ]),\n        knockerNoiseMode: populateField('knockerNoiseMode', 'quic'),\n        noiseCountMin: populateField('noiseCountMin', 10),\n        noiseCountMax: populateField('noiseCountMax', 15),\n        noiseSizeMin: populateField('noiseSizeMin', 5),\n        noiseSizeMax: populateField('noiseSizeMax', 10),\n        noiseDelayMin: populateField('noiseDelayMin', 1),\n        noiseDelayMax: populateField('noiseDelayMax', 1),\n        amneziaNoiseCount: populateField('amneziaNoiseCount', 5),\n        amneziaNoiseSizeMin: populateField('amneziaNoiseSizeMin', 50),\n        amneziaNoiseSizeMax: populateField('amneziaNoiseSizeMax', 100),\n        panelVersion: httpConfig.panelVersion\n    };\n\n    try {\n        await env.kv.put(\"proxySettings\", JSON.stringify(settings));\n    } catch (error) {\n        console.log(error);\n        throw new Error(`An error occurred while updating KV - ${error}`);\n    }\n\n    return settings;\n}\n\nfunction extractChainProxyParams(chainProxy) {\n    if (!chainProxy) return {};\n    const {\n        hostname,\n        port,\n        username,\n        password,\n        search,\n        protocol\n    } = new URL(chainProxy);\n\n    const proto = protocol.slice(0, -1);\n    let configParams = {\n        protocol: proto === 'ss' ? atob('c2hhZG93c29ja3M=') : proto,\n        server: hostname,\n        port: +port\n    };\n\n    const parseParams = () => {\n        const params = new URLSearchParams(search);\n        for (const [key, value] of params) {\n            configParams[key] = value;\n        }\n    }\n\n    switch (proto) {\n        case atob('dmxlc3M='):\n            configParams.uuid = username;\n            parseParams();\n            break;\n\n        case atob('dHJvamFu'):\n            configParams.password = username;\n            parseParams();\n            break;\n\n        case atob('c3M='):\n            const auth = new TextDecoder().decode(Uint8Array.from(atob(username), c => c.charCodeAt(0)));\n            const [first, ...rest] = auth.split(':');\n            configParams.method = first;\n            configParams.password = rest.join(':');\n            parseParams();\n            break;\n\n        case atob('c29ja3M='):\n        case 'http':\n            configParams.user = username;\n            configParams.pass = password;\n            break;\n\n        default:\n            return {};\n    }\n\n    return configParams;\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/protocols/warp.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":21,"column":36,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":41},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":51,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":51,"endColumn":33},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":57,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'crypto' is not defined.","line":61,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":21},{"ruleId":"no-undef","severity":2,"message":"'btoa' is not defined.","line":64,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":64,"endColumn":39}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export async function fetchWarpConfigs(env) {\n    const warpConfigs = [];\n    const apiBaseUrl = 'https://api.cloudflareclient.com/v0a4005/reg';\n    const warpKeys = [\n        await generateKeyPair(), \n        await generateKeyPair()\n    ];\n\n    const commonPayload = {\n        install_id: \"\",\n        fcm_token: \"\",\n        tos: new Date().toISOString(),\n        type: \"Android\",\n        model: 'PC',\n        locale: 'en_US',\n        warp_enabled: true\n    };\n\n    const fetchAccount = async (key) => {\n        try {\n            const response = await fetch(apiBaseUrl, {\n                method: 'POST',\n                headers: {\n                    'User-Agent': 'insomnia/8.6.1',\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({ ...commonPayload, key: key.publicKey })\n            });\n            \n            return await response.json();\n        } catch (error) {\n            throw new Error(\"Failed to get warp configs.\", error);\n        }\n    };\n\n    for (const key of warpKeys) {\n        const accountData = await fetchAccount(key);\n        warpConfigs.push({\n            privateKey: key.privateKey,\n            account: accountData\n        });\n    }\n\n    const configs = JSON.stringify(warpConfigs)\n    await env.kv.put('warpConfigs', configs);\n    \n    return configs;\n}\n\nasync function generateKeyPair() {\n    const keyPair = await crypto.subtle.generateKey(\n        { name: \"X25519\", namedCurve: \"X25519\" },\n        true,\n        [\"deriveBits\"]\n    );\n\n    const pkcs8 = await crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey);\n    const privateKeyRaw = new Uint8Array(pkcs8).slice(-32);\n\n    const publicKeyRaw = new Uint8Array(\n        await crypto.subtle.exportKey(\"raw\", keyPair.publicKey)\n    );\n\n    const base64Encode = (arr) => btoa(String.fromCharCode(...arr));\n\n    return { \n        publicKey: base64Encode(publicKeyRaw), \n        privateKey: base64Encode(privateKeyRaw) \n    };\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/protocols/websocket/common.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":48,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":48,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":62,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":62,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":68,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":68,"endColumn":20},{"ruleId":"no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":79,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":79,"endColumn":19},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":80,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'err' is not defined.","line":80,"column":45,"nodeType":"Identifier","messageId":"undef","endLine":80,"endColumn":48},{"ruleId":"no-undef","severity":2,"message":"'WritableStream' is not defined.","line":91,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":91,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":101,"column":50,"nodeType":"Identifier","messageId":"undef","endLine":101,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":117,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":117,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":122,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":20},{"ruleId":"no-undef","severity":2,"message":"'ReadableStream' is not defined.","line":137,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":137,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'controller' is defined but never used.","line":176,"column":14,"nodeType":"Identifier","messageId":"unusedVar","endLine":176,"endColumn":24,"suggestions":[{"messageId":"removeVar","data":{"varName":"controller"},"fix":{"range":[7148,7158],"text":""},"desc":"Remove unused variable 'controller'."}]},{"ruleId":"no-undef","severity":2,"message":"'atob' is not defined.","line":205,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":28},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":219,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":219,"endColumn":16}],"suppressedMessages":[],"errorCount":14,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { connect } from 'cloudflare:sockets';\nimport { isIPv4, parseHostPort, resolveDNS } from '#configs/utils';\nimport { wsConfig } from '#common/init';\n\nexport const WS_READY_STATE_OPEN = 1;\nconst WS_READY_STATE_CLOSING = 2;\n\nexport async function handleTCPOutBound(\n    remoteSocket,\n    addressRemote,\n    portRemote,\n    rawClientData,\n    webSocket,\n    VLResponseHeader,\n    log\n) {\n    async function connectAndWrite(address, port) {\n        // if (/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?).){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(address)) address = `${atob('d3d3Lg==')}${address}${atob('LnNzbGlwLmlv')}`;\n        const tcpSocket = connect({\n            hostname: address,\n            port: port,\n        });\n\n        remoteSocket.value = tcpSocket;\n        log(`connected to ${address}:${port}`);\n        const writer = tcpSocket.writable.getWriter();\n        await writer.write(rawClientData); // first write, nomal is tls client hello\n        writer.releaseLock();\n        return tcpSocket;\n    }\n\n    async function retry() {\n        let tcpSocket;\n        const { proxyMode, panelIPs } = wsConfig;\n        const getRandomValue = (arr) => arr[Math.floor(Math.random() * arr.length)];\n        const parseIPs = (value) => value ? value.split(',').map(val => val.trim()).filter(Boolean) : undefined;\n\n        if (proxyMode === 'proxyip') {\n            log(`direct connection failed, trying to use Proxy IP for ${addressRemote}`);\n\n            try {\n                const proxyIPs = parseIPs(wsConfig.envProxyIPs) ||  wsConfig.defaultProxyIPs;\n                const ips = panelIPs.length ? panelIPs : proxyIPs;\n                const proxyIP = getRandomValue(ips);\n                const { host, port } = parseHostPort(proxyIP, true);\n                tcpSocket = await connectAndWrite(host || addressRemote, port || portRemote);\n            } catch (error) {\n                console.error('Proxy IP connection failed:', error);\n                webSocket.close(1011, 'Proxy IP connection failed: ' + error.message);\n            }\n\n        } else if (proxyMode === 'prefix') {\n            log(`direct connection failed, trying to generate dynamic prefix for ${addressRemote}`);\n\n            try {\n                const prefixes = parseIPs(wsConfig.envPrefixes) || wsConfig.defaultPrefixes;\n                const ips = panelIPs.length ? panelIPs : prefixes;\n                const prefix = getRandomValue(ips);\n                const dynamicProxyIP = await getDynamicProxyIP(addressRemote, prefix);\n                tcpSocket = await connectAndWrite(dynamicProxyIP, portRemote);\n            } catch (error) {\n                console.error('Prefix connection failed:', error);\n                webSocket.close(1011, 'Prefix connection failed: ' + error.message);\n            }\n        }\n\n        tcpSocket.closed.catch(error => {\n            console.log('retry tcpSocket closed error', error);\n        }).finally(() => {\n            safeCloseWebSocket(webSocket);\n        });\n\n        remoteSocketToWS(tcpSocket, webSocket, VLResponseHeader, null, log);\n    }\n\n    try {\n        const tcpSocket = await connectAndWrite(addressRemote, portRemote);\n        remoteSocketToWS(tcpSocket, webSocket, VLResponseHeader, retry, log);\n    } catch (error) {\n        console.error('Connection failed:', err);\n        webSocket.close(1011, 'Connection failed');\n    }\n}\n\nasync function remoteSocketToWS(remoteSocket, webSocket, VLResponseHeader, retry, log) {\n    // remote--> ws\n    let VLHeader = VLResponseHeader;\n    let hasIncomingData = false; // check if remoteSocket has incoming data\n    await remoteSocket.readable\n        .pipeTo(\n            new WritableStream({\n                start() { },\n                async write(chunk, controller) {\n                    hasIncomingData = true;\n                    // remoteChunkCount++;\n                    if (webSocket.readyState !== WS_READY_STATE_OPEN) {\n                        controller.error(\"webSocket.readyState is not open, maybe close\");\n                    }\n\n                    if (VLHeader) {\n                        webSocket.send(await new Blob([VLHeader, chunk]).arrayBuffer());\n                        VLHeader = null;\n                    } else {\n                        // seems no need rate limit this, CF seems fix this??..\n                        // if (remoteChunkCount > 20000) {\n                        // \t// cf one package is 4096 byte(4kb),  4096 * 20000 = 80M\n                        // \tawait delay(1);\n                        // }\n                        webSocket.send(chunk);\n                    }\n                },\n                close() {\n                    log(`remoteConnection!.readable is close with hasIncomingData is ${hasIncomingData}`);\n                    // safeCloseWebSocket(webSocket); // no need server close websocket frist for some case will casue HTTP ERR_CONTENT_LENGTH_MISMATCH issue, client will send close event anyway.\n                },\n                abort(reason) {\n                    console.error(`remoteConnection!.readable abort`, reason);\n                },\n            })\n        )\n        .catch((error) => {\n            console.error(`VLRemoteSocketToWS has exception `, error.stack || error);\n            safeCloseWebSocket(webSocket);\n        });\n\n    // seems is cf connect socket have error,\n    // 1. Socket.closed will have error\n    // 2. Socket.readable will be close without any data coming\n    if (hasIncomingData === false && retry) {\n        log(`retry`);\n        retry();\n    }\n}\n\nexport function makeReadableWebSocketStream(webSocketServer, earlyDataHeader, log) {\n    let readableStreamCancel = false;\n    const stream = new ReadableStream({\n        start(controller) {\n            webSocketServer.addEventListener(\"message\", (event) => {\n\n                if (readableStreamCancel) {\n                    return;\n                }\n\n                const message = event.data;\n                controller.enqueue(message);\n            });\n\n            // The event means that the client closed the client -> server stream.\n            // However, the server -> client stream is still open until you call close() on the server side.\n            // The WebSocket protocol says that a separate close message must be sent in each direction to fully close the socket.\n            webSocketServer.addEventListener(\"close\", () => {\n                // client send close, need close server\n                // if stream is cancel, skip controller.close\n                safeCloseWebSocket(webSocketServer);\n\n                if (readableStreamCancel) {\n                    return;\n                }\n\n                controller.close();\n            });\n            webSocketServer.addEventListener(\"error\", (err) => {\n                log(\"webSocketServer has error\");\n                controller.error(err);\n            });\n            // for ws 0rtt\n            const { earlyData, error } = base64ToArrayBuffer(earlyDataHeader);\n\n            if (error) {\n                controller.error(error);\n            } else if (earlyData) {\n                controller.enqueue(earlyData);\n            }\n        },\n        pull(controller) {\n            // if ws can stop read if stream is full, we can implement backpressure\n            // https://streams.spec.whatwg.org/#example-rs-push-backpressure\n        },\n        cancel(reason) {\n            // 1. pipe WritableStream has error, this cancel will called, so ws handle server close into here\n            // 2. if readableStream is cancel, all controller.close/enqueue need skip,\n            // 3. but from testing controller.error still work even if readableStream is cancel\n            if (readableStreamCancel) {\n                return;\n            }\n\n            log(`ReadableStream was canceled, due to ${reason}`);\n            readableStreamCancel = true;\n            safeCloseWebSocket(webSocketServer);\n        },\n    });\n\n    return stream;\n}\n\nfunction base64ToArrayBuffer(base64Str) {\n    if (!base64Str) {\n        return { earlyData: null, error: null };\n    }\n\n    try {\n        // go use modified Base64 for URL rfc4648 which js atob not support\n        base64Str = base64Str.replace(/-/g, '+').replace(/_/g, '/');\n        const decode = atob(base64Str);\n        const arryBuffer = Uint8Array.from(decode, (c) => c.charCodeAt(0));\n        return { earlyData: arryBuffer.buffer, error: null };\n    } catch (error) {\n        return { earlyData: null, error };\n    }\n}\n\nexport function safeCloseWebSocket(socket) {\n    try {\n        if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING) {\n            socket.close();\n        }\n    } catch (error) {\n        console.error('safeCloseWebSocket error', error);\n    }\n}\n\nasync function getDynamicProxyIP(address, prefix) {\n    let finalAddress = address;\n\n    if (!isIPv4(address)) {\n        const { ipv4 } = await resolveDNS(address, true);\n\n        if (ipv4.length) {\n            finalAddress = ipv4[0];\n        } else {\n            throw new Error('Unable to find IPv4 in DNS records');\n        }\n    }\n\n    return convertToNAT64IPv6(finalAddress, prefix);\n}\n\nfunction convertToNAT64IPv6(ipv4Address, prefix) {\n    const parts = ipv4Address.split('.');\n\n    if (parts.length !== 4) {\n        throw new Error('Invalid IPv4 address');\n    }\n\n    const hex = parts.map(part => {\n        const num = parseInt(part, 10);\n\n        if (num < 0 || num > 255) {\n            throw new Error('Invalid IPv4 address');\n        }\n\n        return num.toString(16).padStart(2, '0');\n    });\n\n    const match = prefix.match(/^\\[([0-9A-Fa-f:]+)\\]$/);\n\n    if (match) {\n        return `[${match[1]}${hex[0]}${hex[1]}:${hex[2]}${hex[3]}]`;\n    }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/protocols/websocket/trojan.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'WebSocketPair' is not defined.","line":5,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":5,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":11,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":11,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'WritableStream' is not defined.","line":22,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":22,"endColumn":31},{"ruleId":"no-unused-vars","severity":2,"message":"'controller' is defined but never used.","line":23,"column":36,"nodeType":"Identifier","messageId":"unusedVar","endLine":23,"endColumn":46,"suggestions":[{"messageId":"removeVar","data":{"varName":"controller"},"fix":{"range":[878,890],"text":""},"desc":"Remove unused variable 'controller'."}]},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":73,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":73,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'TextDecoder' is not defined.","line":96,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":96,"endColumn":37},{"ruleId":"security/detect-possible-timing-attacks","severity":1,"message":"Potential timing attack, left side: true","line":97,"column":5,"nodeType":"IfStatement","endLine":102,"endColumn":6},{"ruleId":"no-undef","severity":2,"message":"'TextDecoder' is not defined.","line":136,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":38},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":255,"column":13,"nodeType":"MemberExpression","endLine":255,"endColumn":17},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":265,"column":13,"nodeType":"MemberExpression","endLine":265,"endColumn":17},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":273,"column":43,"nodeType":"MemberExpression","endLine":273,"endColumn":47},{"ruleId":"security/detect-object-injection","severity":1,"message":"Generic Object Injection Sink","line":273,"column":50,"nodeType":"MemberExpression","endLine":273,"endColumn":54}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { handleTCPOutBound, makeReadableWebSocketStream } from '#protocols/websocket/common';\nimport { globalConfig } from '#common/init';\n\nexport async function TrOverWSHandler(request) {\n    const webSocketPair = new WebSocketPair();\n    const [client, webSocket] = Object.values(webSocketPair);\n    webSocket.accept();\n    let address = \"\";\n    let portWithRandomLog = \"\";\n    const log = (info, event) => {\n        console.log(`[${address}:${portWithRandomLog}] ${info}`, event || \"\");\n    };\n    const earlyDataHeader = request.headers.get(\"sec-websocket-protocol\") || \"\";\n    const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);\n    let remoteSocketWapper = {\n        value: null,\n    };\n    let udpStreamWrite = null;\n\n    readableWebSocketStream\n        .pipeTo(\n            new WritableStream({\n                async write(chunk, controller) {\n                    if (udpStreamWrite) {\n                        return udpStreamWrite(chunk);\n                    }\n\n                    if (remoteSocketWapper.value) {\n                        const writer = remoteSocketWapper.value.writable.getWriter();\n                        await writer.write(chunk);\n                        writer.releaseLock();\n                        return;\n                    }\n\n                    const {\n                        hasError,\n                        message,\n                        portRemote = 443,\n                        addressRemote = \"\",\n                        rawClientData,\n                    } = parseTRHeader(chunk);\n\n                    address = addressRemote;\n                    portWithRandomLog = `${portRemote}--${Math.random()} tcp`;\n\n                    if (hasError) {\n                        throw new Error(message);\n                        // return;\n                    }\n\n                    handleTCPOutBound(\n                        remoteSocketWapper,\n                        addressRemote,\n                        portRemote,\n                        rawClientData,\n                        webSocket,\n                        null,\n                        log\n                    );\n                },\n                close() {\n                    log(`readableWebSocketStream is closed`);\n                },\n                abort(reason) {\n                    log(`readableWebSocketStream is aborted`, JSON.stringify(reason));\n                },\n            })\n        )\n        .catch((err) => {\n            log(\"readableWebSocketStream pipeTo error\", err);\n        });\n\n    return new Response(null, {\n        status: 101,\n        // @ts-ignore\n        webSocket: client,\n    });\n}\n\nfunction parseTRHeader(buffer) {\n    if (buffer.byteLength < 56) {\n        return {\n            hasError: true,\n            message: \"invalid data\",\n        };\n    }\n\n    let crLfIndex = 56;\n    if (new Uint8Array(buffer.slice(56, 57))[0] !== 0x0d || new Uint8Array(buffer.slice(57, 58))[0] !== 0x0a) {\n        return {\n            hasError: true,\n            message: \"invalid header format (missing CR LF)\",\n        };\n    }\n\n    const password = new TextDecoder().decode(buffer.slice(0, crLfIndex));\n    if (password !== sha224(globalConfig.TrPass)) {\n        return {\n            hasError: true,\n            message: \"invalid password\",\n        };\n    }\n\n    const socks5DataBuffer = buffer.slice(crLfIndex + 2);\n    if (socks5DataBuffer.byteLength < 6) {\n        return {\n            hasError: true,\n            message: \"invalid SOCKS5 request data\",\n        };\n    }\n\n    const view = new DataView(socks5DataBuffer);\n    const cmd = view.getUint8(0);\n    if (cmd !== 1) {\n        return {\n            hasError: true,\n            message: \"unsupported command, only TCP (CONNECT) is allowed\",\n        };\n    }\n\n    const atype = view.getUint8(1);\n    // 0x01: IPv4 address\n    // 0x03: Domain name\n    // 0x04: IPv6 address\n    let addressLength = 0;\n    let addressIndex = 2;\n    let address = \"\";\n    switch (atype) {\n        case 1:\n            addressLength = 4;\n            address = new Uint8Array(socks5DataBuffer.slice(addressIndex, addressIndex + addressLength)).join(\".\");\n            break;\n        case 3:\n            addressLength = new Uint8Array(socks5DataBuffer.slice(addressIndex, addressIndex + 1))[0];\n            addressIndex += 1;\n            address = new TextDecoder().decode(socks5DataBuffer.slice(addressIndex, addressIndex + addressLength));\n            break;\n        case 4: {\n            addressLength = 16;\n            const dataView = new DataView(socks5DataBuffer.slice(addressIndex, addressIndex + addressLength));\n            const ipv6 = [];\n            for (let i = 0; i < 8; i++) {\n                ipv6.push(dataView.getUint16(i * 2).toString(16));\n            }\n            address = ipv6.join(\":\");\n            break;\n        }\n        default:\n            return {\n                hasError: true,\n                message: `invalid addressType is ${atype}`,\n            };\n    }\n\n    if (!address) {\n        return {\n            hasError: true,\n            message: `address is empty, addressType is ${atype}`,\n        };\n    }\n\n    const portIndex = addressIndex + addressLength;\n    const portBuffer = socks5DataBuffer.slice(portIndex, portIndex + 2);\n    const portRemote = new DataView(portBuffer).getUint16(0);\n    return {\n        hasError: false,\n        addressRemote: address,\n        portRemote,\n        rawClientData: socks5DataBuffer.slice(portIndex + 4),\n    };\n}\n\nfunction sha224(string) {\n    const rightRotate = (value, amount) => (value >>> amount) | (value << (32 - amount));\n\n    const h = [\n        0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n        0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4\n    ];\n\n    const k = [\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    ];\n\n    const utf8Encode = (str) => {\n        const utf8 = [];\n\n        for (let i = 0; i < str.length; i++) {\n            let charcode = str.charCodeAt(i);\n\n            if (charcode < 0x80) {\n                utf8.push(charcode);\n            } else if (charcode < 0x800) {\n                utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));\n            } else if (charcode < 0xd800 || charcode >= 0xe000) {\n                utf8.push(\n                    0xe0 | (charcode >> 12),\n                    0x80 | ((charcode >> 6) & 0x3f),\n                    0x80 | (charcode & 0x3f)\n                );\n            } else {\n                i++;\n                charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));\n                utf8.push(\n                    0xf0 | (charcode >> 18),\n                    0x80 | ((charcode >> 12) & 0x3f),\n                    0x80 | ((charcode >> 6) & 0x3f),\n                    0x80 | (charcode & 0x3f)\n                );\n            }\n        }\n\n        return utf8;\n    };\n\n    const bytes = utf8Encode(string);\n    const bitLength = bytes.length * 8;\n\n    bytes.push(0x80);\n\n    while ((bytes.length % 64) !== 56) {\n        bytes.push(0);\n    }\n\n    const lengthHi = Math.floor(bitLength / 0x100000000);\n    const lengthLo = bitLength & 0xffffffff;\n\n    for (let i = 3; i >= 0; i--) {\n        bytes.push((lengthHi >> (i * 8)) & 0xff);\n    }\n\n    for (let i = 3; i >= 0; i--) {\n        bytes.push((lengthLo >> (i * 8)) & 0xff);\n    }\n\n    for (let offset = 0; offset < bytes.length; offset += 64) {\n        const w = new Array(64).fill(0);\n\n        for (let i = 0; i < 16; i++) {\n            w[i] =\n                (bytes[offset + 4 * i] << 24) |\n                (bytes[offset + 4 * i + 1] << 16) |\n                (bytes[offset + 4 * i + 2] << 8) |\n                bytes[offset + 4 * i + 3];\n        }\n\n        for (let i = 16; i < 64; i++) {\n            const s0 = rightRotate(w[i - 15], 7) ^ rightRotate(w[i - 15], 18) ^ (w[i - 15] >>> 3);\n            const s1 = rightRotate(w[i - 2], 17) ^ rightRotate(w[i - 2], 19) ^ (w[i - 2] >>> 10);\n            w[i] = (w[i - 16] + s0 + w[i - 7] + s1) | 0;\n        }\n\n        let [a, b, c, d, e, f, g, h8] = h;\n\n        for (let i = 0; i < 64; i++) {\n            const S1 = rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25);\n            const ch = (e & f) ^ (~e & g);\n            const temp1 = (h8 + S1 + ch + k[i] + w[i]) | 0;\n            const S0 = rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22);\n            const maj = (a & b) ^ (a & c) ^ (b & c);\n            const temp2 = (S0 + maj) | 0;\n\n            h8 = g;\n            g = f;\n            f = e;\n            e = (d + temp1) | 0;\n            d = c;\n            c = b;\n            b = a;\n            a = (temp1 + temp2) | 0;\n        }\n\n        h[0] = (h[0] + a) | 0;\n        h[1] = (h[1] + b) | 0;\n        h[2] = (h[2] + c) | 0;\n        h[3] = (h[3] + d) | 0;\n        h[4] = (h[4] + e) | 0;\n        h[5] = (h[5] + f) | 0;\n        h[6] = (h[6] + g) | 0;\n        h[7] = (h[7] + h8) | 0;\n    }\n\n    return h\n        .slice(0, 7)\n        .map((word) => ('00000000' + (word >>> 0).toString(16)).slice(-8))\n        .join('');\n}\n","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/protocols/websocket/vless.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'WebSocketPair' is not defined.","line":6,"column":31,"nodeType":"Identifier","messageId":"undef","endLine":6,"endColumn":44},{"ruleId":"no-undef","severity":2,"message":"'console' is not defined.","line":14,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'WritableStream' is not defined.","line":25,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":25,"endColumn":54},{"ruleId":"no-undef","severity":2,"message":"'Response' is not defined.","line":98,"column":16,"nodeType":"Identifier","messageId":"undef","endLine":98,"endColumn":24},{"ruleId":"no-undef","severity":2,"message":"'TextDecoder' is not defined.","line":166,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":166,"endColumn":43},{"ruleId":"no-undef","severity":2,"message":"'TransformStream' is not defined.","line":249,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":249,"endColumn":48},{"ruleId":"no-unused-vars","severity":2,"message":"'controller' is defined but never used.","line":250,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":250,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"controller"},"fix":{"range":[7998,8008],"text":""},"desc":"Remove unused variable 'controller'."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'controller' is defined but never used.","line":262,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":262,"endColumn":25,"suggestions":[{"messageId":"removeVar","data":{"varName":"controller"},"fix":{"range":[8665,8675],"text":""},"desc":"Remove unused variable 'controller'."}]},{"ruleId":"no-undef","severity":2,"message":"'WritableStream' is not defined.","line":268,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":268,"endColumn":31},{"ruleId":"no-undef","severity":2,"message":"'fetch' is not defined.","line":270,"column":40,"nodeType":"Identifier","messageId":"undef","endLine":270,"endColumn":45},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":290,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":290,"endColumn":58},{"ruleId":"no-undef","severity":2,"message":"'Blob' is not defined.","line":292,"column":54,"nodeType":"Identifier","messageId":"undef","endLine":292,"endColumn":58}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { isValidUUID } from '#common/handlers';\nimport { globalConfig } from '#common/init';\nimport { handleTCPOutBound, makeReadableWebSocketStream, WS_READY_STATE_OPEN } from '#protocols/websocket/common';\n\nexport async function VlOverWSHandler(request) {\n    const webSocketPair = new WebSocketPair();\n    const [client, webSocket] = Object.values(webSocketPair);\n\n    webSocket.accept();\n\n    let address = \"\";\n    let portWithRandomLog = \"\";\n    const log = (info, event) => {\n        console.log(`[${address}:${portWithRandomLog}] ${info}`, event || \"\");\n    };\n    const earlyDataHeader = request.headers.get(\"sec-websocket-protocol\") || \"\";\n    const readableWebSocketStream = makeReadableWebSocketStream(webSocket, earlyDataHeader, log);\n    let remoteSocketWapper = {\n        value: null,\n    };\n    let udpStreamWrite = null;\n    let isDns = false;\n\n    // ws --> remote\n    readableWebSocketStream.pipeTo(new WritableStream({\n        async write(chunk) {\n            if (isDns && udpStreamWrite) {\n                return udpStreamWrite(chunk);\n            }\n\n            if (remoteSocketWapper.value) {\n                const writer = remoteSocketWapper.value.writable.getWriter();\n                await writer.write(chunk);\n                writer.releaseLock();\n                return;\n            }\n\n            const {\n                hasError,\n                message,\n                portRemote = 443,\n                addressRemote = \"\",\n                rawDataIndex,\n                VLVersion = new Uint8Array([0, 0]),\n                isUDP,\n            } = processVLHeader(chunk, globalConfig.userID);\n\n            address = addressRemote;\n            portWithRandomLog = `${portRemote}--${Math.random()} ${isUDP ? \"udp \" : \"tcp \"} `;\n\n            if (hasError) {\n                // controller.error(message);\n                throw new Error(message); // cf seems has bug, controller.error will not end stream\n                // webSocket.close(1000, message);\n                // return;\n            }\n\n            // [\"version\", \"附加信息长度 N\"]\n            const VLResponseHeader = new Uint8Array([VLVersion[0], 0]);\n            const rawClientData = chunk.slice(rawDataIndex);\n\n            // if UDP but port not DNS port, close it\n            if (isUDP) {\n                if (portRemote === 53) {\n                    isDns = true;\n                    const { write } = await handleUDPOutBound(webSocket, VLResponseHeader, log);\n                    udpStreamWrite = write;\n                    udpStreamWrite(rawClientData);\n                    return;\n                } else {\n                    // controller.error('UDP proxy only enable for DNS which is port 53');\n                    throw new Error(\"UDP proxy only enable for DNS which is port 53\"); // cf seems has bug, controller.error will not end stream\n                    // return;\n                }\n            }\n\n            handleTCPOutBound(\n                remoteSocketWapper,\n                addressRemote,\n                portRemote,\n                rawClientData,\n                webSocket,\n                VLResponseHeader,\n                log\n            );\n        },\n        close() {\n            log(`readableWebSocketStream is close`);\n        },\n        abort(reason) {\n            log(`readableWebSocketStream is abort`, JSON.stringify(reason));\n        },\n    }))\n        .catch((err) => {\n            log(\"readableWebSocketStream pipeTo error\", err);\n        });\n\n    return new Response(null, {\n        status: 101,\n        webSocket: client,\n    });\n}\n\nfunction processVLHeader(VLBuffer, userID) {\n    if (VLBuffer.byteLength < 24) {\n        return {\n            hasError: true,\n            message: \"invalid data\",\n        };\n    }\n\n    const version = new Uint8Array(VLBuffer.slice(0, 1));\n    let isValidUser = false;\n    let isUDP = false;\n    const slicedBuffer = new Uint8Array(VLBuffer.slice(1, 17));\n    const slicedBufferString = stringify(slicedBuffer);\n    isValidUser = slicedBufferString === userID;\n\n    if (!isValidUser) {\n        return {\n            hasError: true,\n            message: \"invalid user\",\n        };\n    }\n\n    const optLength = new Uint8Array(VLBuffer.slice(17, 18))[0];\n    //skip opt for now\n    const command = new Uint8Array(VLBuffer.slice(18 + optLength, 18 + optLength + 1))[0];\n\n    // 0x01 TCP\n    // 0x02 UDP\n    // 0x03 MUX\n    if (command === 1) { /* empty */ } else if (command === 2) {\n        isUDP = true;\n    } else {\n        return {\n            hasError: true,\n            message: `command ${command} is not support, command 01-tcp,02-udp,03-mux`,\n        };\n    }\n\n    const portIndex = 18 + optLength + 1;\n    const portBuffer = VLBuffer.slice(portIndex, portIndex + 2);\n    // port is big-Endian in raw data etc 80 == 0x005d\n    const portRemote = new DataView(portBuffer).getUint16(0);\n\n    let addressIndex = portIndex + 2;\n    const addressBuffer = new Uint8Array(VLBuffer.slice(addressIndex, addressIndex + 1));\n\n    // 1--> ipv4  addressLength =4\n    // 2--> domain name addressLength=addressBuffer[1]\n    // 3--> ipv6  addressLength =16\n    const addressType = addressBuffer[0];\n    let addressLength = 0;\n    let addressValueIndex = addressIndex + 1;\n    let addressValue = \"\";\n\n    switch (addressType) {\n        case 1:\n            addressLength = 4;\n            addressValue = new Uint8Array(VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength)).join(\".\");\n            break;\n        case 2:\n            addressLength = new Uint8Array(VLBuffer.slice(addressValueIndex, addressValueIndex + 1))[0];\n            addressValueIndex += 1;\n            addressValue = new TextDecoder().decode(VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength));\n            break;\n        case 3: {\n            addressLength = 16;\n            const dataView = new DataView(VLBuffer.slice(addressValueIndex, addressValueIndex + addressLength));\n            // 2001:0db8:85a3:0000:0000:8a2e:0370:7334\n            const ipv6 = [];\n            for (let i = 0; i < 8; i++) {\n                ipv6.push(dataView.getUint16(i * 2).toString(16));\n            }\n            addressValue = ipv6.join(\":\");\n            // seems no need add [] for ipv6\n            break;\n        }\n        default:\n            return {\n                hasError: true,\n                message: `invild  addressType is ${addressType}`,\n            };\n    }\n\n    if (!addressValue) {\n        return {\n            hasError: true,\n            message: `addressValue is empty, addressType is ${addressType}`,\n        };\n    }\n\n    return {\n        hasError: false,\n        addressRemote: addressValue,\n        addressType,\n        portRemote,\n        rawDataIndex: addressValueIndex + addressLength,\n        VLVersion: version,\n        isUDP,\n    };\n}\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 256).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n    return (\n        byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        \"-\" +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        \"-\" +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        \"-\" +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        \"-\" +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]\n    ).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n\n    if (!isValidUUID(uuid)) {\n        throw TypeError(\"Stringified UUID is invalid\");\n    }\n\n    return uuid;\n}\n\nasync function handleUDPOutBound(webSocket, VLResponseHeader, log) {\n    let isVLHeaderSent = false;\n\n    const transformStream = new TransformStream({\n        start(controller) { },\n        transform(chunk, controller) {\n            // udp message 2 byte is the the length of udp data\n            // TODO: this should have bug, beacsue maybe udp chunk can be in two websocket message\n            for (let index = 0; index < chunk.byteLength;) {\n                const lengthBuffer = chunk.slice(index, index + 2);\n                const udpPakcetLength = new DataView(lengthBuffer).getUint16(0);\n                const udpData = new Uint8Array(chunk.slice(index + 2, index + 2 + udpPakcetLength));\n                index = index + 2 + udpPakcetLength;\n                controller.enqueue(udpData);\n            }\n        },\n        flush(controller) { },\n    });\n\n    // only handle dns udp for now\n    transformStream.readable\n        .pipeTo(\n            new WritableStream({\n                async write(chunk) {\n                    const resp = await fetch(\n                        globalConfig.dohURL, // dns server url\n                        {\n                            method: \"POST\",\n                            headers: {\n                                \"content-type\": \"application/dns-message\",\n                            },\n                            body: chunk,\n                        }\n                    );\n\n                    const dnsQueryResult = await resp.arrayBuffer();\n                    const udpSize = dnsQueryResult.byteLength;\n                    // console.log([...new Uint8Array(dnsQueryResult)].map((x) => x.toString(16)));\n                    const udpSizeBuffer = new Uint8Array([(udpSize >> 8) & 0xff, udpSize & 0xff]);\n\n                    if (webSocket.readyState === WS_READY_STATE_OPEN) {\n                        log(`doh success and dns message length is ${udpSize}`);\n\n                        if (isVLHeaderSent) {\n                            webSocket.send(await new Blob([udpSizeBuffer, dnsQueryResult]).arrayBuffer());\n                        } else {\n                            webSocket.send(await new Blob([VLResponseHeader, udpSizeBuffer, dnsQueryResult]).arrayBuffer());\n                            isVLHeaderSent = true;\n                        }\n                    }\n                },\n            })\n        )\n        .catch((error) => {\n            log(\"dns udp has error\" + error);\n        });\n\n    const writer = transformStream.writable.getWriter();\n\n    return {\n        write(chunk) {\n            writer.write(chunk);\n        },\n    };\n}","usedDeprecatedRules":[]},{"filePath":"/home/set-iitgn-vm/Desktop/Stt_lab2/vuln_lab/BPB-Worker-Panel/src/worker.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]